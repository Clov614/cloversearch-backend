{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1762022491125047297",
        "title": "大四java-准备春招",
        "description": "简历",
        "content": "鱼皮哥，今年大四了，准备参加现在的春招，\n- 想找您看看目前建立还有什么问题么？\n- 我一直没输过算法题，现在刷是不是没有必要了？\n- 我一直到现在才约了3场面试，感觉很紧张，我很头疼这个问题。。。\n\n![c3acbdb62bcbf87aa1250af72e695c0.png](https://pic.code-nav.cn/post_picture/1681534941206155266/fKEyG721-c3acbdb62bcbf87aa1250af72e695c0.png)",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 26,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1681534941206155266",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-26T07:51:13.000+00:00",
        "updateTime": "2024-02-26T14:08:40.000+00:00",
        "user": {
          "id": "1681534941206155266",
          "planetCode": "24896",
          "userName": "放纵",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1681534941206155266/8TcWogu9-csdn头像.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-07-19T04:46:39.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-07-19T05:22:26.000+00:00",
          "updateTime": "2024-02-26T07:29:44.000+00:00"
        },
        "tags": [
          "文章",
          "简历"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1761043295141748738",
        "title": "MySQL学习",
        "description": "关于MySQL约束的学习",
        "content": "## 约束\n#### 1、概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n#### 2、目的：保证数据库中数据的正确、有效性和完整性。\n#### 3、分类：\n\n| 约束 | 描述 |  关键字  | \n| --- | --- |---|\n| 非空约束 | 限制该字段的数据不能为null | not null|\n|唯一约束|\t保证该字段的所有数据都是唯一，不重复\t|unique|\n|主键约束|\t主键是一行数据的唯一标识，要求非空且唯一（自增：auto_increment）|\tprimary key|\n|默认约束\t|保存数据时，如果未指定该字段的值，则采用默认值\t|default|\n|检查约束（8.0.16版本之后）|保证字段值满足某一个条件\t|check|\n|外键约束\t|用来让两张表的数据之间建立连接，保证数据的一致性和完整性|\tforeign key|\n\n*注意：\n约束是作用于表中字段上的，可以创建表/修改表的时候添加约束。*\n\n外键约束：\n具有外键的是子表，外键所关联的是父表\n语法如下：\n\n```sql\n-- 添加外键\ncreate table 表名(\n  字段名 数据类型，\n  ...\n  [constraint] [外键名称] foreign key(外键名称) references 主表(主表列名)\n  \n);\n-- 或者\nalter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名)\n```\n\n```sql\n-- 删除外键\nalter table 表名 drop foreign key 外键名称 \n\n```\n外键的删除/更新行为\n\n| 行为 | 说明 |\n| --- | --- |\n| no action | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与RESTRICT一致) |\n| restrict | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与NOACTON 一致) |\n| cascade | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 |\n| set null | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为nul(这就要求该外键允许取null)。 |\n| set default | 父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持) |\n\n设置外键行为语法\n\n```sql\nalter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名(主表字段名) on update cascade on delete cascade\n-- on updae 意思是在更新时采取什么行为\n-- on delete 意思是在删除时采取什么行为\n```\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 23,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1747537878507896833",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-23T15:00:14.000+00:00",
        "updateTime": "2024-02-26T13:28:37.000+00:00",
        "user": {
          "id": "1747537878507896833",
          "planetCode": "32623",
          "userName": "划船不用桨",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1747537878507896833/ZVW3Wp8C-微信图片_20240221213145.jpg",
          "gender": 1,
          "userProfile": "打工仔一个",
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": "1997-09-03",
          "school": "",
          "major": null,
          "education": "专科",
          "graduationYear": 2021,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 2,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2025-02-18T00:59:43.000+00:00",
          "lastLoginTime": null,
          "createTime": "2024-01-17T08:34:32.000+00:00",
          "updateTime": "2024-02-22T01:18:45.000+00:00"
        },
        "tags": [
          "文章",
          "数据库"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760869013241585665",
        "title": "什么是Redis？",
        "description": null,
        "content": "Redis是开源的，使用ANSIC语言编写的遵循BSD许可，是一个高性能的Key-Value数据库，提供了丰富的数据结构，例如String、Hash、List、Set、SortedSet等等。数据是存在内存中的，同时Redis支持事务、持久化、Lua脚本、发布/订阅、缓存淘汰、流技术等多种功能特性提供了主从模式、Redis Sentinel和Redis Cluster集群架构方案",
        "category": "面试题",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 21,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608812742599245826",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-23T03:27:42.000+00:00",
        "updateTime": "2024-02-26T13:31:38.000+00:00",
        "user": {
          "id": "1608812742599245826",
          "planetCode": "5185",
          "userName": "葛成",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/sqZ24tHwumJ8fHiabmZOqemicECaic6INZmtXAOzf6lXq4P7NaPwiaCLW29O7cc3v1JGibnMuse3mJcVNCtnw4LBwrQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 3,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-04-22T04:22:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-30T13:10:22.000+00:00",
          "updateTime": "2024-02-24T02:11:42.000+00:00"
        },
        "tags": [
          "面试题",
          "Redis"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760679073350279169",
        "title": "模板引擎-Thymeleaf与Freemarker",
        "description": "关于模板引擎Thymeleaf与Freemarker的笔记",
        "content": "# 模板引擎\n\n模板引擎：将数据和页面显示分离。\n\n模板文件 + 数据  -->  模板引擎  -->  html\n\n通过正则表达式来识别哪些是固定不变的模板，哪些是变化的数据，用已有的API（如：不同的表达式类型）把什么样的数据用什么格式来渲染进去，根据提供好的规则，模板引擎就可以解析出来。\n\nJSP的局限性\n\n1）springboot内嵌容器时（打成jar包），不支持JSP。\n如果要运行JSP需要打成war包，则需要使用外部容器。\n\n2）undertow容器是不支持JSP的。\n\n3）扩展性有限，对于一些默认处理，很难自定义。\n\n4）在容器化技术（如docket）中，对JSP的使用也很繁杂。\n\n\n因为JSP有这么多的局限性，所以有了模板引擎\n\n\n较早的模板引擎：velocity、freemarker\n\n国人开发的模板：beetl\n\n\n# Thymeleaf\n\n自然的模板，动静分离，是一个处理纯文本的模板引擎。\n\n## 引入thymeleaf命名空间\n\n```html\n<!--引入thymeleaf的命名空间，使用时才有提示-->\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n```\n\n## 表达式\n\n`${}` 变量表达式，引用一个变量\n\n`*{}` 选择变量表达式，当我们通过${}拿到一个对象时，可以通过*{}拿到这个对象的属性值\n\n`#{}` 消息表达式，可以通过配置文件拿到某些数据，还可以用来实现国际化效果 \n\n`@{}` 链接表达式\n\n`~{}` 片段表达式，引用相同的代码片段\n\n\n## 字符串的拼接\n\n```html\n<p th:text=\"${person.name} + ' is ' + ${person.age}\"></p>\n<!--使用 | 将${}的内容替换成对象，其余的不变-->\n<p th:text=\"|${person.name} is ${person.age}|\"></p>\n```\n\n## 条件判断\n\n### if的使用\n\n```html\n<p th:if=\"${msg=='yes'}\">这是第一个msg的取值：</p>\n<p th:text=\"${msg}\" th:if=\"${msg=='yes'}\"></p>\n<p th:if=\"${msg=='no'}\">这是第二个msg的取值：</p>\n<p th:text=\"${msg}\" th:if=\"${msg=='no'}\"></p>\n```\n\n### unless的使用\n\n```html\n<p th:unless=\"${msg=='yes'}\">这是第一个msg的取值：</p>\n<p th:text=\"${msg}\" th:unless=\"${msg=='yes'}\"></p>\n<!--当msg的值不等于no时进行展示，所以下面的会展示出来-->\n<p th:unless=\"${msg=='no'}\">这是第二个msg的取值：</p>\n<p th:text=\"${msg}\" th:unless=\"${msg=='no'}\"></p>\n```\n\n### switch的使用\n\n```html\n<div th:switch=\"${num}\">\n\t<p th:case=\"1\">1</p>\n\t<p th:case=\"2\">2</p>\n\t<p th:case=\"*\">*</p>\n</div>\n```\n\n## for循环\n\n### th:each\n\n```html\n<table>\n    <thead>\n\t<tr>\n            <th>名字</th>\n            <th>年龄</th>\n\t</tr>\n    </thead>\n    <tbody>\n\t<tr th:each=\"data:${list}\">\n            <td th:text=\"${data.name}\">name</td>\n            <td th:text=\"${data.age}\">age</td>\n\t</tr>\n    </tbody>\n</table>\n```\n\n### 状态变量\n\n默认命名是：参数名+Stat（如上的：dataStat），用来**保存迭代状态**\n\n自定义的命名是：`<tr th:each=\"data,status:${list}\">` 此时状态变量名为status\n\n状态变量的属性：\n```\nindex\t索引，从0开始\ncount\t计数，从1开始\nsize\t\t集合的大小\ncurrent\t当前对象\nfirst / last\t布尔类型，是否是第一个/最后一个\neven / odd\t布尔类型，是否是 偶数 / 奇数 个\n```\n\n```html\n<table>\n\t<thead>\n\t<tr>\n\t\t<th>名字</th>\n\t\t<th>年龄</th>\n\t\t<th>index</th>\n\t\t<th>count</th>\n\t\t<th>size</th>\n\t\t<th>current</th>\n\t\t<th>first</th>\n\t\t<th>last</th>\n\t\t<th>even</th>\n\t\t<th>odd</th>\n\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr th:each=\"data:${list}\">\n\t\t<td th:text=\"${data.name}\">name</td>\n\t\t<td th:text=\"${data.age}\">age</td>\n\t\t<td th:text=\"${dataStat.index}\">index</td>\n\t\t<td th:text=\"${dataStat.count}\">count</td>\n\t\t<td th:text=\"${dataStat.size}\">size</td>\n\t\t<td th:text=\"${dataStat.current}\">current</td>\n\t\t<td th:text=\"${dataStat.first}\">first</td>\n\t\t<td th:text=\"${dataStat.last}\">last</td>\n\t\t<td th:text=\"${dataStat.even}\">even</td>\n\t\t<td th:text=\"${dataStat.odd}\">odd</td>\n\t</tr>\n\t</tbody>\n</table>\n```\n\n## URL的使用\n\n### 基础使用\n\n```html\n<form th:action=\"@{/login}\" method=\"post\">\n\tusername:\n\t<input type=\"text\" name=\"username\">\n\tpassword:\n\t<input type=\"password\" name=\"password\">\n\t\n\t<input type=\"submit\" value=\"提交\">\n</form>\n```\n\n### 绝对路径\n\n#### 1、基本用法\n\n```html\n<a th:href=\"@{http://cn.bing.com}\">外链到：bing</a>\n<!--渲染效果为<a href=\"http://cn.bing.com\">外链到：bing</a>-->\n```\n\n#### 2、协议自动识别补全\n\n**使用方法：\t开头用 //**\n\n以引用静态资源举例：\n\n```html\n<script type=\"text/javascript\" th:src=\"@{//code.jquery.com/jquery-3.4.1.min.js}\"></script>\n```\n\n渲染结果：\n`<script type=\"text/javascript\" src=\"[//code.jquery.com/jquery-3.4.1.min.js](http://code.jquery.com/jquery-3.4.1.min.js)\"></script>`\n\n### 相对路径\n\n#### 1、上下文相关的URL\n\n##### 1）基本用法\n\n`<form th:action=\"@{/login}\" method=\"post\">`\n比如说：部署项目的地址\tlocalhost:8080/demo\n渲染结果为： <form action=\"/demo/login\" method=\"post\">\n验证方式：在配置文件中增加`server.servlet.context-path=/demo`\n\n##### 2）引用静态资源的方式\n\n先利用springboot的依赖配置\n\n```xml\n<dependency>\n    <groupId>org.webjars</groupId>\n    <artifactId>jquery</artifactId>\n    <version>3.4.1</version>\n</dependency>\n```\n\n接着在某个html文件中引用\n\n```html\n<script type=\"text/javascript\" th:src=\"@{/webjars/jquery/3.4.1/jquery.js}\"></script>\n```\n\n##### 3）参数的使用\n\n请求中携带参数\n    \na）携带一个参数时，如：/addPerson?id=1\n       在表达式中使用：@{/addPerson(id=1)}\t\t\n       **单个参数的使用，用括号括起来**\n    \nb）携带多个参数时，如：/addPerson?id=1&name='lsq'\n      在表达式中使用：@{/addPerson(id=1,name='lsq')}\t\n      **用括号将多个参数括起来，参数之间用逗号隔开**\n    \nc）当参数是路径的一部分时，如：\t/addPerson/1?name='lsq'\n      在表达式中使用：@{/addPerson/{id}(id=1,name='lsq')}\n      **支持路径中包含变量  可以使用参数去替换**\n\n#### 2、服务器相关URL\n\n` <a th:href=\"@{~/a.html}\"></a> `\n\n通过 **~** 知道指定的是服务器某个地址，就不是和项目相关的，这样不同的项目可以访问同一个服务器下的某个文件。\n    \n渲染结果为：`<a href=\"/a.html\">`\n    \n**不会增加上下文路径（项目访问路径），可以访问同一个服务器上的不同项目，访问到固定地址。**\n\n**补充：**\n\n![image1.png](https://pic.code-nav.cn/post_picture/1632761346305089537/iaJ4pFBS-image1.png)\n\n    \n## 内置对象/内嵌变量\n\n工具类的使用：（使用方式是\t**加前缀#**）\n    \ndates、calendars、numbers、strings、objects、bools、arrays、lists、sets、Maps\n\n日期dates\n    \n日期格式化：#datas.format()\n\n```html\n<!--dates的使用-->\n<p th:text=\"${date}\"></p>\n<p th:text=\"${#dates.format(date,'yyyy-MM-dd HH:mm:ss')}\"></p>\n\n<!--拿到当前的时间-->\n<p  th:text=\"${#dates.createNow()}\"></p>\n<p th:text=\"${#dates.createToday()}\"></p>\n```\n\nstrings的使用\n\n```html\n<!--strings的使用-->\n<p th:text=\"${#strings.isEmpty(str)}\"></p>\n<p th:text=\"${#strings.length(str)}\"></p>\n<p th:text=\"${#strings.equals(str,'duing')}\"></p>\n```\n\n\n## 表达式语言\n\nOGNL：Object-Graph Navigation Language 对象视图导航语言\n\n可以通过表达式语言，来获取Java的对象，在JavaWeb中使用较多\n\nSpEL：基于Spring的表达式语言，提供给我们一种运行时对象的交互能力\n本质都是\t在视图层和控制层将数据建立联系的方式\n\n```html\n<p th:text=\"${ 1 * 2 + 3 - 4}\"></p>\n\n<p th:text=\"${list[0].name}\"></p>\n\n<p th:text=\"${T(java.lang.Math).random()}\"></p>\n```\n\n## 内联表达式\n\n用两个中括号 **[ [ ] ]** 将一个引用的对象括起来，对象本身还是 **${}** 获取，这样就能将展示的信息与其它字符串拼接起来了。（展示文本的时候简化逻辑）\n    \n凡是可以用 th:text 或 th:utext 显示的内容都可以用内联表达式来转换。\n\n`th:text`\t=>\t`[[...]]`\t转义了，若含有标签，标签效果不起作用\n    \n`th:utext`\t=>\t`[(...)]`    不转义，按照标签效果输出\n如果文本需要展示含`[[]]`的数据，可以禁用内联表达式。\n\n```html\n<p> 加油，[[${info}]] </p>\n<p> 加油，<span th:text=\"${info}\"></span> </p>\n\n<!--禁用内联表达式-->\n<p th:inline=\"none\"> 加油，[[<span th:text=\"${info}\"></span>]] </p>\n```\n\n**内联JavaScript**\n    \n当给JavaScript中传一些数据的时候，使用内联JavaScript\n\n```html\n<script type=\"text/javascript\" th:inline=\"javascript\">\n\t//var info = [[${info}]];\n\t<!--内联js，同样支持动静分离,使用 /**/ 将动态数据引起来，在其后跟上静态数据，但这样使用之后原来的注释就不能用了，同时还有一个局限性：在外部js文件里不能使用，在html文件中的js代码生效 -->\n\tvar info = /*[[${info}]]*/ 123;\n\tconsole.log(info);\n</script>\n```\n\n类似js，同样支持css\n\n```html\n<style th:inline=\"css\">\n</style>\n```\n\n## 碎片代码\n\n**th:fragment，th:include，th:replace，th:insert**\n    \n有些网页内容，需要在许多网页中使用，可以使用`th:fragment`在某个独立的（网页）标签中设置碎片代码，并为其命名。\n    \n在需要引入碎片代码的网页中使用`th:include、th:replace、th:insert`等引入。\n    \n**include，replace，insert的区别：**\n\n- include是只引进碎片代码的内容，不把其标签属性引入（即不引入碎片标签），保留原有的标签属性\n- replace与include相反，只引入碎片代码的内容，引入碎片标签，不保留原有的标签\n- insert是即引入碎片标签，也保留原有标签（当样式冲突时，碎片标签属性起作用，看网页源码可知）\n\n\n![image2.png](https://pic.code-nav.cn/post_picture/1632761346305089537/EDPke2QY-image2.png)\n    \n\n# Freemarker\n\n一个用java编写的模板引擎，适合作为web项目中的视图层组件，是生成文本的工具。\n    \nftl文件本质也是html格式的\n    \nfreemarker区分大小写\n    \nftl组成部分：文本（静态的），插值（动态的），标签，注释 **<#--  -->** \n\n## 使用步骤\n\n**1）引入freemarker依赖**\n\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-freemarker</artifactId>\n</dependency>\n```\n\n**2）增加自定义的配置文件**\n\n```properties\n#旧的使用方式\n# 文件位置\n#spring.mvc.view.prefix=/templates\n# 文件后缀\n#spring.mvc.view.suffix=.ftl\n\n#新的使用方式\n# 文件位置\nspring.freemarker.template-loader-path=classpath:/templates\n# 文件后缀\nspring.freemarker.suffix=.ftl\n```\n\n**3）编写controller及ftl文件**\n\n## 字符串的使用\n\n定义变量：**<#assign** info1 = 'how are you?'>\n字符串的拼接：<p>Hello ${info **+** info1}</p>\n字符串的内嵌函数：（调用时使用 **字符串名?** ）\n\n<p>${info1?substring(0,3)}</p>\t<#--左闭右开-->\n<p>${info1?length}</p>\n\n```html\n<p>Hello ${info}</p><br>\n\n<#--定义变量-->\n<#assign info1 = 'how are you?'>\n<#--字符串的拼接-->\n<p>Hello ${info + info1}</p>\n<#--字符串的内嵌函数-->\n<p>${info1?substring(0,3)}</p><#--左闭右开-->\n<p>${info1?length}</p>\n```\n\n## 条件判断\n\n```html\n<#assign num = 666>\n<#if num == 666>\n\t<p>666</p>\n<#elseif num == 888>\n\t<p>888</p>\n<#else>\n\t<p>000</p>\n</#if>\n```\n\n```html\n<#switch num>\n\t<#case 666>\n\t\t<p>666</p>\n\t\t<#break>\n\t<#case 888>\n\t\t<p>888</p>\n\t\t<#break>\n\t<#default>\n\t\t<p>000</p>\n</#switch>\n```\n\n## 列表\n\n```html\n<#assign myList = [1,3,5,7,10,9]>\n<h5>无序数组：</h5>\n<#list myList as item>\n\t${item}\n</#list>\n<br>\n<h5>有序数组：</h5>\n<#list myList?sort as item>\n\t${item}\n</#list>\n<br>\n\t\n<#list [1,2,3] as item>\n\t${item}\n</#list>\n<br>\n\t\n<#list 1..3 as item>\n\t${item}\n</#list>\n<br>\n\t\n<#--元素的别名 缀上 _index  代表下标-->\n<#list 1..3 as item>\n\t${item_index}\t<#--获取索引-->\n\t, ${item}<br>\n</#list>\n\t\n<#list 1..3 as item>\n\t<#--判断是否有下一项-->\n\t<#if item_has_next>\n\t\t${item}\n\t</#if>\n</#list>\n```\n\n## 判断变量是否为空\n\n```html\n<#--判断变量是否为空：通过 ! 来判断-->\n<#--<#assign str = 'str'>-->\n${str!\"default\"}\n```\n\n## 引入其它文件的值\n\n在一个html中引入另一个html中的一些变量的值，不仅能读取，还能修改\n\n```html\n<#import 'other.ftl' as otherFtl>\n${otherFtl.name} <br>\n<#--不仅可以读取到它的值，还能修改它的值-->\n<#assign name = 'welcome ftl is here' in otherFtl>\n${otherFtl.name}\n```\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 15,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1632761346305089537",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-22T14:52:57.000+00:00",
        "updateTime": "2024-02-26T08:47:35.000+00:00",
        "user": {
          "id": "1632761346305089537",
          "planetCode": "18875",
          "userName": "举个栗子~",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1632761346305089537/y7rrvMgi-可达鸭头像.png",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [
            "面试题",
            "面试题挑战",
            "简历",
            "面试",
            "开源",
            "软件"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2025-03-06T13:53:57.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-03-06T15:13:34.000+00:00",
          "updateTime": "2024-02-22T13:57:59.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760652938952433665",
        "title": "常见设计模式在星球OJ和聚合搜索项目中的应用",
        "description": "介绍星球OJ和聚合搜索项目中使用的常用设计模式",
        "content": "在近期的开发中，笔者主要参与了星球OJ（[OJ 判题系统（亮点多） - 飞书云文档 (feishu.cn)](https://yuyuanweb.feishu.cn/wiki/LhjxwgFjwiovTVk9w2vcJoj4nid)）和聚合搜索（[聚合搜索平台（中台设计） - 飞书云文档 (feishu.cn)](https://yuyuanweb.feishu.cn/wiki/RigVw1gAdiXIfLkj6ktclEDQn7e)）两个项目。在这两个项目中，均使用了设计模式来使代码变得“优雅”。直观来说，让代码的简洁度、可读性和拓展性都得到了一定程度的提升。\n\n正所谓“学以致用”，那么就跟着笔者的节奏，来从以上两个项目的实际场景中来学习和体会设计模式吧~\n\n## 1. OJ项目\n\n主要使用的设计模式有：\n\n1. 代理模式\n2. 工厂模式\n3. 策略模式\n4. 模板方法模式\n\n### 1.1. 代码沙箱的开发：模板方法模式\n\n（引自菜鸟教程）\n\n在模板方法模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\n\n**意图：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。\n\n**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n\n**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n**使用场景：** 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n\n![S3s2W.png](https://i0.imgs.ovh/2024/02/21/S3s2W.png)\n\n在代码沙箱的开发中，针对不同代码语言的代码执行，逻辑都是相同的，只是在具体实现的方法细节存在差异。因此，我们可以通过提取“执行代码”共有的逻辑和方法，封装至模板类中，然后创建不同语言的“执行代码子类”交由“客户端”来调用和处理对应的代码语言，得到执行结果。\n\n**首先，**我们提取并创建“执行代码”抽象类角色![S3xIv.png](https://i0.imgs.ovh/2024/02/21/S3xIv.png)\n\n**然后，**我们针对不同的语言，继承公共类，得到对应的子类（以处理Java语言代码的子类为例）：\n\n![S3Kze.png](https://i0.imgs.ovh/2024/02/21/S3Kze.png)\n\n**而且，**在子类中，我们除了可以使用父类已有的方法，也可以实现抽象方法，也可以自行添加对应的方法，比如，Java需要编译代码，那么我们就可以添加“编译代码”方法，Python无需编译，则无需添加此方法。\n\n### 1.2. 代码沙箱对象的生成：工厂模式\n\n（引自菜鸟教程）\n\n工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。\n\n工厂模式属于创建型模式，它在创建对象时提供了一种封装机制，将实际创建对象的代码与使用代码分离。\n\n**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n\n**何时使用：**我们明确地计划不同条件下创建不同实例时。\n\n**优点：** 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。\n\n**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n\n**注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n\n**工厂模式包含以下几个核心角色：**\n\n- 抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。\n- 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。\n- 抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。\n- 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。\n\n![S3oC3.png](https://i0.imgs.ovh/2024/02/21/S3oC3.png)\n\n在OJ系统中，我们需要再判题时调用“代码沙箱”服务，而代码沙箱的种类通常不止一种，比如：远程第三方代码沙箱、本地代码沙箱、其他厂商代码沙箱等，对此我们首先会将其交由不同的子类来处理（实现同一代码沙箱接口），然后**针对不同的条件，来创建不同的子类沙箱对象**来使用，这时，就可以用到工厂模式。\n\n**首先，**我们拥有若干种类的“代码沙箱”子类：\n\n![S3Sm9.png](https://i0.imgs.ovh/2024/02/21/S3Sm9.png)\n\n**然后，**我们创建代码沙箱工厂类来根据选择的条件来生成相应的子类对象：\n\n![S3ucO.png](https://i0.imgs.ovh/2024/02/21/S3ucO.png)\n\n**最后，**我们在使用时，只需指定对应的“代码沙箱type”，即可得到对应的代码沙箱使用对象：\n\n![S379H.png](https://i0.imgs.ovh/2024/02/21/S379H.png)\n\n### 1.3. 代码沙箱对象方法的调用：代理模式\n\n（引自菜鸟教程）\n\n在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。\n\n在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n\n**意图：**为其他对象提供一种代理以控制对这个对象的访问。\n\n**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n\n**如何解决：**增加中间层，实现与被代理类组合。\n\n**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。\n\n**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n\n**主要涉及到以下几个核心角色：**\n\n- **抽象主题（Subject）:**\n\n- - 定义了真实主题和代理主题的共同接口，这样在任何使用真实主题的地方都可以使用代理主题。\n\n- **真实主题（Real Subject）:**\n\n- - 实现了抽象主题接口，是代理对象所代表的真实对象。客户端直接访问真实主题，但在某些情况下，可以通过代理主题来间接访问。\n\n- **代理（Proxy）:**\n\n- - 实现了抽象主题接口，并持有对真实主题的引用。代理主题通常在真实主题的基础上提供一些额外的功能，例如延迟加载、权限控制、日志记录等。\n\n- **客户端（Client）:**\n\n- - 使用抽象主题接口来操作真实主题或代理主题，不需要知道具体是哪一个实现类。\n\n![S3QHD.png](https://i0.imgs.ovh/2024/02/21/S3QHD.png)\n\n承接1.2，在得到“代码沙箱子类对象”后，我们要调用其“执行代码”的方法，但我们希望能够在执行原方法的同时添加一些额外的操作（如，打印方法日志），同时不影响原方法，那么就可以创建一个代理类，来代理原代码沙箱子类对象。\n\n**首先，**创建代理类：\n\n![S3RSo.png](https://i0.imgs.ovh/2024/02/21/S3RSo.png)\n\n**然后，**就可以使用代理类去调用“执行代码（新）”方法：\n\n![S3cdA.png](https://i0.imgs.ovh/2024/02/21/S3cdA.png)\n\n### 1.4. 多语言代码的判题：策略模式\n\n（引自菜鸟教程）\n\n在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n\n在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。\n\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n\n**意图：**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n\n**主要解决：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。\n\n**何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。\n\n**如何解决：**将这些算法封装成一个一个的类，任意地替换。\n\n**关键代码：**实现同一个接口。\n\n**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。\n\n**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。\n\n**使用场景：** 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n\n**策略模式包含以下几个核心角色：**\n\n- 环境（Context）：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。\n- 抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。\n- 具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。\n\n策略模式通过将算法与使用算法的代码解耦，提供了一种动态选择不同算法的方法。客户端代码不需要知道具体的算法细节，而是通过调用环境类来使用所选择的策略。\n\n![S3g25.png](https://i0.imgs.ovh/2024/02/21/S3g25.png)\n\n在OJ系统中，不同语言代码的题目判题，方法相同，但方法的具体实现策略有所不同，因此可以使用策略模式来根据代码语言“环境”的不同选择不同的算法策略。\n\n**首先，**创建不同语言的策略子类（实现统一抽象判题接口）：\n\n![S3ths.png](https://i0.imgs.ovh/2024/02/21/S3ths.png)\n\n**然后，**创建“上下文对象”来统一“环境”类的参数：\n\n![S31UX.png](https://i0.imgs.ovh/2024/02/21/S31UX.png)\n\n**最后，**就可以创建“环境”类，来实现动态切换策略：\n\n![S3zCU.png](https://i0.imgs.ovh/2024/02/21/S3zCU.png)\n\n## 2. 聚合搜索项目\n\n主要使用的设计模式有：\n\n1. 适配器模式\n2. 注册器模式\n\n### 2.1. 多数据源搜索接口调用：适配器模式\n\n（引自菜鸟教程）\n\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。\n\n这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。\n\n**优点：** 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。\n\n**缺点：** 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。\n\n**使用场景：**有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。\n\n**注意事项：**适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\n\n![S3U60.png](https://i0.imgs.ovh/2024/02/21/S3U60.png)\n\n在聚合搜索项目中，我们需要从不同数据源中检索数据，那么就需要调用不同数据源接口的方法，而这些方法一般方法参数都存在差异，我们无法直接方便的统一调用，只能使用分支结构做复杂的代码逻辑，此时我们就可以引入适配器模式，将分支结构的代码从客户端调用方拆分后移至抽象适配器接口的各个子类中，统一适配器类的参数，从而方便客户端便捷、统一的使用。\n\n**首先，**创建适配器接口，制定统一的规范，即统一方法名和参数格式：\n\n![S3ieC.png](https://i0.imgs.ovh/2024/02/21/S3ieC.png)\n\n**然后，**实现不同数据源的实现子类（实现适配器接口）：\n\n![S3j9t.png](https://i0.imgs.ovh/2024/02/21/S3j9t.png)\n\n![S35Mm.png](https://i0.imgs.ovh/2024/02/21/S35Mm.png)\n\n**最后，**客户端即可通过适配器接口，来统一获取不同数据源的查询结果：\n\n![S3YSN.png](https://i0.imgs.ovh/2024/02/21/S3YSN.png)\n\n### 2.2. 特定搜索接口子类对象使用：注册器模式\n\n注册器模式是一种基础常见的设计模式，它的主要意思是把多个类的实例注册到一个注册器类中去，然后需要哪个类，由这个注册器类统一调取。\n\n（引自ChatGPT）\n\n- **优点**：\n\n- - 提供了一种统一的注册和查找机制，使得系统更加灵活，易于维护和扩展。\n  - 可以动态地向注册器中注册和移除对象，实现了松耦合。\n\n- **缺点**：\n\n- - 可能会导致注册器对象过于庞大，难以维护和理解。\n  - 对象的生命周期由注册器管理，可能会导致内存泄漏或者对象过早被销毁的问题。\n\n实现起来也很简单，在聚合搜索项目中，可以将“适配器接口”的各个子类加入同一注册器，便于统一调取，从而减少了客户端调用方法的代码量：\n\n![S3ddR.png](https://i0.imgs.ovh/2024/02/21/S3ddR.png)\n\n![S3DFp.png](https://i0.imgs.ovh/2024/02/21/S3DFp.png)",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 18,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1721896042632441858",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-22T13:09:06.000+00:00",
        "updateTime": "2024-02-26T13:12:23.000+00:00",
        "user": {
          "id": "1721896042632441858",
          "planetCode": "29240",
          "userName": "南侠（准）",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELkfM4IsxxWrB70flGuaDcq55mDxh8r4DuwOJLuluSmRCH9Pk1MFibry5icVgHtfwMmnYGqT49svVKV3X1wMer2OCC3ob5leZX5lF8HMbPo1Qww/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-11-05T14:14:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-11-07T14:23:02.000+00:00",
          "updateTime": "2024-02-02T00:50:41.000+00:00"
        },
        "tags": [
          "文章",
          "后端",
          "笔记"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760560210990194690",
        "title": "伙伴匹配引入 GEO 实现搜索附近用户",
        "description": "伙伴匹配引入 Reids GEO 实现搜索附近用户功能",
        "content": "## 前言\n\n鱼皮哥在直播中提出可以通过Redis GEO实现编辑距离和搜索附近用户功能，也算是是一个拓展点。这个项目我做完有一个多月了，最近在做其拓展功能顺便也把这个功能实现一波，整体的实现并不困难，学完 Redis 再看会更轻松（未学过也没事）。话不多说直接开始撸代码吧。\n\n### 设计思路和流程\n1. 在 User（用户）表中添加两个字段 longitude（经度）和 dimension（维度），用以存储用户的经纬度坐标。因为Redis GEO 通过每个用户的经纬度坐标计算用户间的距离，同时其 Redis 数据类型为ZSET，ZSET 是一个有序的 List 类似 Java 的 SortedSet。在此场景 value 就是用户id，score 是经纬度信息（ ZSET 根据 score值升序排序）。\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/ukGNy7Pm-image.png)\n\n```sql\ncreate table hjj.user\n(\n    username     varchar(256)                       null comment '用户昵称',\n    id           bigint auto_increment comment 'id'\n        primary key,\n    userAccount  varchar(256)                       null comment '账户',\n    avatarUrl    varchar(1024)                      null comment '用户头像',\n    gender       tinyint                            null comment '用户性别',\n    profile      varchar(512)                       null comment '个人简介',\n    userPassword varchar(512)                       not null comment '用户密码',\n    phone        varchar(128)                       null comment '电话',\n    email        varchar(512)                       null comment '邮箱',\n    userStatus   int      default 0                 not null comment '状态 0 - 正常',\n    createTime   datetime default CURRENT_TIMESTAMP null comment '创建时间',\n    updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment '更新时间',\n    isDelete     tinyint  default 0                 not null comment '是否删除',\n    userRole     int      default 0                 not null comment '用户角色 0 - 普通用户 1 - 管理员',\n    planetCode   varchar(512)                       null comment '星球编号',\n    tags         varchar(1024)                      null comment '标签列表(json)',\n    longitude    decimal(10, 6)                     null comment '经度',\n    dimension    decimal(10, 6)                     null comment '纬度'\n)\n    comment '用户';\n```\n\n2. 在 UserVO 类中添加distance字段，用以向前端返回每个用户与自己之间的距离，类型为Double。\n\n```java\n/**\n * 用户信息封装类\n */\n@Data\npublic class UserVO {\n    /**\n     * id\n     */\n    private long id;\n\n    /**\n     * 用户昵称\n     */\n    private String username;\n\n    /**\n     * 账户\n     */\n    private String userAccount;\n\n    /**\n     * 用户头像\n     */\n    private String avatarUrl;\n\n    /**\n     * 用户性别\n     */\n    private Integer gender;\n    /**\n     * 用户简介\n     */\n    private String profile;\n\n    /**\n     * 电话\n     */\n    private String phone;\n\n    /**\n     * 邮箱\n     */\n    private String email;\n\n    /**\n     * 状态 0 - 正常\n     */\n    private Integer userStatus;\n\n    /**\n     * 创建时间\n     */\n    private Date createTime;\n\n    /**\n     * 更新时间\n     */\n    private Date updateTime;\n\n    /**\n     * 用户角色 0 - 普通用户 1 - 管理员\n     */\n    private Integer userRole;\n\n    /**\n     * 星球编号\n     */\n    private String planetCode;\n    /**\n     * 标签列表 json\n     */\n    private String tags;\n\n    /**\n     * 用户距离\n     */\n    private Double distance;\n\n    private static final long serialVersionUID = 1L;\n}\n```\n\n\n## 基本业务实现\n\n### 导入各个用户经纬度数据\n编写测试类导入各个用户的经纬度信息并且写入Redis中，Redis GEO会根据它计算出一个 score值。进行 Redis GEO 相关操作时可以使用 Spring Data Redis 提供现成的操作 Redis 的模板——StringRedisTemplate，注意其 Key/Value 都是String类型。\n\nstringRedisTemplate.opsForGeo().add() 支持一次一次地传入经纬度信息，可以通过List和Map集合类型传入用户经纬度信息，这里我们用List集合。第一个参数为Redis的key，这不用过多介绍。第二个参数为List类型，泛型为RedisGeoCommands.GeoLocation<String>，其参数为用户id和Point（Point可以理解为是一个圆的一个点吧，经纬度就是x/y坐标）。\n\nstringRedisTemplate.opsForGeo().add()传入的参数：\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/aCG2wGnt-image.png)\n\n```java\n    @Test\n    public void importUserGEOByRedis() {\n        List<User> userList = userService.list(); // 查询所有用户\n        String key = RedisConstant.USER_GEO_KEY; // Redis的key\n        List<RedisGeoCommands.GeoLocation<String>> locationList = new ArrayList<>(userList.size()); // 初始化地址（经纬度）List\n        for (User user : userList) {\n            locationList.add(new RedisGeoCommands.GeoLocation<>(String.valueOf(user.getId()), new Point(user.getLongitude(),\n                    user.getDimension()))); // 往locationList添加每个用户的经纬度数据\n        }\n        stringRedisTemplate.opsForGeo().add(key, locationList); // 将每个用户的经纬度信息写入Redis中\n    }\n```\n\n结果：\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/hAnnMABF-image.png)\n\n\n### 获取用户 id = 1 与其他用户的距离\n编写一个测试类计算用户 id = 1 与其他用户之间的距离。利用stringRedisTemplate.opsForGeo().distance()方法，其主要参数为member1和member2，Metric是计算距离的单位类型。从名称就可以知道member1和member2其实就是用户1和用户2的信息，因为我们在上面用 locationList.add() 添加用户id和用户的经度坐标，所以这两个member就是用户id咯。\n\n所以写个循环就可以算出用户 id = 1 与其他用户的距离\n```java\n    @Test\n    public void getUserGeo() {\n        String key = RedisConstant.USER_GEO_KEY;\n        List<User> userList = userService.list();\n\n        // 计算每个用户与登录用户的距离\n        for (User user : userList) {\n            Distance distance = stringRedisTemplate.opsForGeo().distance(key,\n                    \"1\", String.valueOf(user.getId()), RedisGeoCommands.DistanceUnit.KILOMETERS);\n            System.out.println(\"User: \" + user.getId() + \", Distance: \" +\n                    distance.getValue() + \" \" + distance.getUnit());\n        }\n    }\n```\n\n结果：\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/lYSYVUBZ-image.png)\n\n### 搜索附近用户\n\n利用现成的 stringRedisTemplate.opsForGeo().radius 方法，第一个参数依然是Redis的key，第二个参数是Circle，看代码和名称就知道其是一个圆（传入Point即圆心和圆的半径）。想象搜索附近的用户就是搜索以你为圆心，半径为搜索距离的圆内的用户。理解这些代码就能顺理成章的撸出来了，是不是不算难。\n\n```java\n    @Test\n    public void searchUserByGeo() {\n        User loginUser = userService.getById(1);\n        Distance geoRadius = new Distance(1500, RedisGeoCommands.DistanceUnit.KILOMETERS);\n        Circle circle  = new Circle(new Point(loginUser.getLongitude(), loginUser.getDimension()), geoRadius);\n        RedisGeoCommands.GeoRadiusCommandArgs geoRadiusCommandArgs = RedisGeoCommands.GeoRadiusCommandArgs\n                .newGeoRadiusArgs().includeCoordinates();\n        GeoResults<RedisGeoCommands.GeoLocation<String>> results = stringRedisTemplate.opsForGeo().radius(RedisConstant.USER_GEO_KEY, circle, geoRadiusCommandArgs);\n        for (GeoResult<RedisGeoCommands.GeoLocation<String>> result : results) {\n            if (!result.getContent().getName().equals(\"1\")) {\n                System.out.println(result.getContent().getName()); // 打印1500km内的用户id\n            }\n        }\n    }\n```\n\n注意：搜索附近的用户会搜索到自己，所以可以加一个判断以排除自己。\n\n结果：\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/LKL1E1ne-image.png)\n\n## 应用至伙伴匹配项目\n\n### 改写用户推荐接口\n我的recommend接口未从Redis缓存中读取数据，而是直接走数据库读取数据，有能力的可以自己实现，我后续也会实现的。同时注意返回类型是UserVO不是User，因为我的前端展示了推荐用户和自己之间的距离。\n\nUserController.recommendUsers:\n```java\n    @GetMapping(\"/recommend\")\n    public BaseResponse<List<UserVO>> recommendUsers(long pageSize, long pageNum, HttpServletRequest request){\n        User loginUser = userService.getLoginUser(request);\n        QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n        queryWrapper.ne(\"id\", loginUser.getId());\n        IPage<User> page = new Page<>(pageNum, pageSize);\n        IPage<User> userIPage = userService.page(page, queryWrapper);\n\n        String redisUserGeoKey = RedisConstant.USER_GEO_KEY;\n        // 将User转换为UserVO\n        List<UserVO> userVOList = userIPage.getRecords().stream()\n                .map(user -> {\n                    // 查询距离\n                    Distance distance = stringRedisTemplate.opsForGeo().distance(redisUserGeoKey,\n                            String.valueOf(loginUser.getId()), String.valueOf(user.getId()),\n                            RedisGeoCommands.DistanceUnit.KILOMETERS);\n                    double value = distance.getValue();\n\n                    // 创建UserVO对象并设置属性\n                    UserVO userVO = new UserVO();\n                    // 这里可以用BeanUtils.copyProperties()，就没必要重复set了\n                    userVO.setId(user.getId());\n                    userVO.setUsername(user.getUsername());\n                    userVO.setUserAccount(user.getUserAccount());\n                    userVO.setAvatarUrl(user.getAvatarUrl());\n                    userVO.setGender(user.getGender());\n                    userVO.setProfile(user.getProfile());\n                    userVO.setPhone(user.getPhone());\n                    userVO.setEmail(user.getEmail());\n                    userVO.setUserStatus(user.getUserStatus());\n                    userVO.setCreateTime(user.getCreateTime());\n                    userVO.setUpdateTime(user.getUpdateTime());\n                    userVO.setUserRole(user.getUserRole());\n                    userVO.setPlanetCode(user.getPlanetCode());\n                    userVO.setTags(user.getTags());\n                    userVO.setDistance(value); // 设置距离值\n                    return userVO;\n                })\n                .collect(Collectors.toList());\n        System.out.println(userVOList);\n        return ResultUtils.success(userVOList);\n    }\n```\n    \n\n### 改写匹配用户接口\nUserServiceImpl.matchUsers:\n```java\n    /**\n     * 推荐最匹配的用户\n     * @return\n     */\n    @GetMapping(\"/match\")\n    public BaseResponse<List<UserVO>> matchUsers(long num, HttpServletRequest request){\n        if (num <=0 || num > 20) {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR);\n        }\n        User loginUser = userService.getLoginUser(request);\n        return ResultUtils.success(userService.matchUsers(num ,loginUser));\n    }\n```\nUserServiceImpl.matchUsers:\n```java\n    @Override\n    public List<UserVO> matchUsers(long num, User loginUser) {\n        QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n        queryWrapper.isNotNull(\"tags\");\n        queryWrapper.ne(\"id\", loginUser.getId());\n        queryWrapper.select(\"id\",\"tags\");\n        List<User> userList = this.list(queryWrapper);\n\n        String tags = loginUser.getTags();\n        Gson gson = new Gson();\n        List<String> tagList = gson.fromJson(tags, new TypeToken<List<String>>() {\n        }.getType());\n        // 用户列表的下表 => 相似度'\n        List<Pair<User,Long>> list = new ArrayList<>();\n        // 依次计算当前用户和所有用户的相似度\n        for (int i = 0; i <userList.size(); i++) {\n            User user = userList.get(i);\n            String userTags = user.getTags();\n            //无标签的 或当前用户为自己\n            if (StringUtils.isBlank(userTags) || user.getId() == loginUser.getId()){\n                continue;\n            }\n            List<String> userTagList = gson.fromJson(userTags, new TypeToken<List<String>>() {\n            }.getType());\n            //计算分数\n            long distance = AlgorithmUtils.minDistance(tagList, userTagList);\n            list.add(new Pair<>(user,distance));\n        }\n        //按编辑距离有小到大排序\n        List<Pair<User, Long>> topUserPairList = list.stream()\n                .sorted((a, b) -> (int) (a.getValue() - b.getValue()))\n                .limit(num)\n                .collect(Collectors.toList());\n        //有顺序的userID列表\n        List<Long> userListVo = topUserPairList.stream().map(pari -> pari.getKey().getId()).collect(Collectors.toList());\n\n        //根据id查询user完整信息\n        QueryWrapper<User> userQueryWrapper = new QueryWrapper<>();\n        userQueryWrapper.in(\"id\",userListVo);\n        Map<Long, List<User>> userIdUserListMap = this.list(userQueryWrapper).stream()\n                .map(user -> getSafetyUser(user))\n                .collect(Collectors.groupingBy(User::getId));\n\n        List<User> finalUserList = new ArrayList<>();\n        for (Long userId : userListVo){\n            finalUserList.add(userIdUserListMap.get(userId).get(0));\n        }\n\n        String redisUserGeoKey = RedisConstant.USER_GEO_KEY;\n        List<UserVO> finalUserVOList = finalUserList.stream().map(user -> {\n            Distance distance = stringRedisTemplate.opsForGeo().distance(redisUserGeoKey, String.valueOf(loginUser.getId()),\n                    String.valueOf(user.getId()), RedisGeoCommands.DistanceUnit.KILOMETERS);\n\n\n            UserVO userVO = new UserVO();\n            userVO.setId(user.getId());\n            // 这里可以用BeanUtils.copyProperties()，就没必要重复set了\n            userVO.setUsername(user.getUsername());\n            userVO.setUserAccount(user.getUserAccount());\n            userVO.setAvatarUrl(user.getAvatarUrl());\n            userVO.setGender(user.getGender());\n            userVO.setProfile(user.getProfile());\n            userVO.setPhone(user.getPhone());\n            userVO.setEmail(user.getEmail());\n            userVO.setUserStatus(user.getUserStatus());\n            userVO.setCreateTime(user.getCreateTime());\n            userVO.setUpdateTime(user.getUpdateTime());\n            userVO.setUserRole(user.getUserRole());\n            userVO.setPlanetCode(user.getPlanetCode());\n            userVO.setTags(user.getTags());\n            userVO.setDistance(distance.getValue());\n            return userVO;\n        }).collect(Collectors.toList());\n        return finalUserVOList;\n    }\n```\n\n### 添加搜索附近用户接口\nUserController.searchNearby:\n```java\n/**\n     * 搜索附近用户\n     */\n    @GetMapping(\"/searchNearby\")\n    public BaseResponse<List<UserVO>> searchNearby(int radius, HttpServletRequest request) {\n        if (radius <= 0 || radius > 10000) {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR);\n        }\n        User user = userService.getLoginUser(request);\n        User loginUser = userService.getById(user.getId());\n        List<UserVO> userVOList = userService.searchNearby(radius, loginUser);\n        return ResultUtils.success(userVOList);\n    }\n```\nUserServiceImpl.searchNearby:\n```java\n    @Override\n    public List<UserVO> searchNearby(int radius, User loginUser) {\n        String geoKey = RedisConstant.USER_GEO_KEY;\n        String userId = String.valueOf(loginUser.getId());\n        Double longitude = loginUser.getLongitude();\n        Double dimension = loginUser.getDimension();\n        if (longitude == null || dimension == null) {\n            throw new BusinessException(ErrorCode.NULL_ERROR, \"登录用户经纬度参数为空\");\n        }\n        Distance geoRadius = new Distance(radius, RedisGeoCommands.DistanceUnit.KILOMETERS);\n        Circle circle = new Circle(new Point(longitude, dimension), geoRadius);\n        GeoResults<RedisGeoCommands.GeoLocation<String>> results = stringRedisTemplate.opsForGeo()\n                .radius(geoKey, circle);\n        List<Long> userIdList = new ArrayList<>();\n        for (GeoResult<RedisGeoCommands.GeoLocation<String>> result : results) {\n            String id = result.getContent().getName();\n            if (!userId.equals(id)) {\n                userIdList.add(Long.parseLong(id));\n            }\n        }\n        List<UserVO> userVOList = userIdList.stream().map(\n                id -> {\n                    UserVO userVO = new UserVO();\n                    User user = this.getById(id);\n                    BeanUtils.copyProperties(user, userVO);\n                    Distance distance = stringRedisTemplate.opsForGeo().distance(geoKey, userId, String.valueOf(id),\n                            RedisGeoCommands.DistanceUnit.KILOMETERS);\n                    userVO.setDistance(distance.getValue());\n                    return userVO;\n                }\n        ).collect(Collectors.toList());\n        return userVOList;\n    }\n```\n\n## 前端改动\nIndex.vue:\n```js\n<template>\n  <van-search v-model=\"searchText\" placeholder=\"搜索附近用户\" @search=\"onSearch(searchText)\"/>\n  <van-cell center title=\"心动模式\">\n    <template #right-icon>\n      <van-switch v-model=\"isMatchMode\" size=\"24\" />\n    </template>\n  </van-cell>\n  <user-card-list :user-list=\"userList\" :loading=\"loading\"/>\n  <van-empty v-if=\"!userList || userList.length < 1\" description=\"数据为空\" />\n</template>\n\n<script setup lang=\"ts\">\nimport {ref, watchEffect} from \"vue\";\nimport {useRoute} from \"vue-router\";\n\nimport myAxios from \"../plugins/myAxios.ts\";\nimport UserCardList from \"../components/UserCardList.vue\";\nimport {UserType} from \"../models/user\"\nimport {showToast} from \"vant\";\n\nconst route = useRoute();\nconst { tags } = route.query;\nconst searchText = ref('');\nconst userList = ref([]);\nconst isMatchMode = ref<boolean>(false);\nconst loading = ref(true);\n\n/**\n * 加载数据\n */\nconst loadData = async () => {\n  let userListData;\n  loading.value = true;\n  //心动模式\n  if (isMatchMode.value){\n    const num = 10;\n    userListData = await myAxios.get('user/match',{\n      params: {\n        num,\n      },\n    })\n        .then(function (response) {\n          console.log('/user/match succeed',response);\n          return response?.data;\n        })\n        .catch(function (error) {\n          console.log('/user/match error',error);\n        });\n  }else {\n    //普通用户使用分页查询\n    userListData = await myAxios.get('/user/recommend',{\n      params: {\n        pageSize: 8,\n        pageNum: 1,\n      },\n    })\n        .then(function (response) {\n          console.log('/user/recommend succeed', response);\n          return response?.data;\n        })\n        .catch(function (error) {\n          console.log('/user/recommends error',error);\n        });\n\n  }\n  if (userListData){\n    userListData.forEach((user: UserType) =>{\n      if (user.tags){\n        user.tags = JSON.parse(user.tags);\n      }\n    })\n    userList.value = userListData;\n  }\n  loading.value = false;\n}\n\nwatchEffect(() =>{\n  loadData();\n})\n\nconst onSearch = async (searchText) => {\n  let userListData;\n  loading.value = true;\n  const res = await myAxios.get('/user/searchNearby', {\n    params: {\n      radius: searchText\n    }\n  })\n  if (res?.code === 0) {\n    userListData = res?.data;\n    if (userListData){\n      userListData.forEach((user: UserType) =>{\n        if (user.tags){\n          user.tags = JSON.parse(user.tags);\n        }\n      })\n      userList.value = userListData;\n    }\n    loading.value = false;\n  } else {\n    showToast('搜索失败');\n  }\n  loading.value = false;\n};\n\n</script>\n\n<style scoped>\n\n</style>\n```\n\nuser.d.ts:\n```js\n    export type UserType = {\n        id: number;\n        username: string;\n        userAccount: string;\n        avatarUrl?: string;\n        gender:number;\n        profile?: string;\n        phone: string;\n        email: string;\n        userStatus: number;\n        userRole: number;\n        planetCode: string;\n        createTime: Date;\n        tags: string;\n        distance: number;\n    };\n```\n\nUserCardList.vue:\n```js\n  <template>\n  <van-skeleton title avatar :row=\"3\" :loading=\"loading\" v-for=\"user in userList\">\n  <van-card\n      :desc=\"user.profile\"\n      :title=\"`${user.username}(${user.planetCode})`\"\n      :price=\"`${user.distance} km`\"\n      currency=\"\"\n      :thumb=\"user.avatarUrl\"\n  >\n    <template #tags>\n      <van-tag plain type=\"danger\" v-for=\"tag in user.tags\" style=\"margin-right: 8px; margin-top: 8px\">\n        {{ tag }}\n      </van-tag>\n    </template>\n    <template #footer>\n      <van-button size=\"mini\" @click=\"toIntroUser(user)\">联系我</van-button>\n    </template>\n  </van-card>\n  </van-skeleton>\n\n</template>\n\n  <script setup lang=\"ts\">\n  import {UserType} from \"../models/user\";\n  import {useRouter} from \"vue-router\";\n\n  const router = useRouter();\n\n  interface UserCardListProps{\n    loading: boolean\n    userList: UserType[];\n  }\n  withDefaults(defineProps<UserCardListProps>(), {\n    loading: true,\n  })\n\n  const toIntroUser = (user: UserType) => {\n    router.push({\n      path: '/user/intro',\n      query: {\n        userInfoParam: JSON.stringify(user)\n      }\n    });\n  }\n\n  </script>\n\n  <style scoped>\n\n  </style>\n```\n\n\n如果有些的不对的地方，还请各位及时指正。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1608639807578177538/kDkcJ3Id-OIP.jpg",
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 32,
        "thumbNum": 6,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608639807578177538",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-22T07:00:38.000+00:00",
        "updateTime": "2024-02-26T13:03:46.000+00:00",
        "user": {
          "id": "1608639807578177538",
          "planetCode": "24506",
          "userName": "吃遍全国汉堡\uD83C\uDF54",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/hib5bbuJu0U3DnxEuGVHEiaGEQr55285A2zaluuxopzXxX5xXFwwfbia7uZcbzpQ5HUDIBeZsIq7VMtfdo1icbL86w/132",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [
            "Java"
          ],
          "place": "江苏淮安",
          "birthday": "2003-10-15",
          "school": "",
          "major": "计算机科学与技术",
          "education": "本科",
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": null,
          "blog": "https://blog.csdn.net/xyendjsj?spm=1000.2115.3001.5343",
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-07-04T00:04:09.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-30T01:43:11.000+00:00",
          "updateTime": "2024-02-08T04:37:32.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Redis",
          "伙伴匹配系统"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760507606587269121",
        "title": "图片转 base64 工具",
        "description": "上传一张图片，得到对应的 base64 编码值",
        "content": null,
        "category": "工具",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/4pJZcDcM-图-base64.png",
        "language": null,
        "externalLink": null,
        "componentName": "image-to-base64",
        "viewNum": 36,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-22T03:31:36.000+00:00",
        "updateTime": "2024-02-26T11:35:03.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "admin",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 40,
          "coin": 0,
          "followeeNum": 15,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-04-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2024-02-04T08:45:43.000+00:00"
        },
        "tags": [
          "工具"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760154889335463938",
        "title": " 如何进行 Github 第三方登录详细讲解 （Java 版本）",
        "description": " 如何进行 Github 第三方登录详细讲解 （Java 版本）",
        "content": "# 如何进行 Github 第三方登录详细讲解 （Java 版本）\n\n## 创建一个 Github 应用\n\n1. 点击 Github 的头像\n2. 然后点击设置![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/BpbAXUkY-image.png)\n\n3. 进入设置后，往下滑，点击开发者设置\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/daosmNUV-image.png)\n\n4. 然后点击 Oauth apps\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/S0RwCWae-image.png)\n5. 随后创建一个新的OAuth App\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/5VBiVAxO-image.png)\n6. 可以看到的是期中有几个必填选项，下面我们来一一说明\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/HGRWYic1-image.png)\n\n    1. Application name 这个可以随意填写，就是你的一个应用名字而已\n    2. Homepage URL 填写你自己的前端页面的首页就好了\n    3. Application description 这个就是一个描述，随意填写就好了\n    4. Authorization callback URL 这个就是授权了以后进行身份判断的回调地址，用于自己对第三方信息进行获取，处理，鉴权。比较重要\n    5. 下面是一个填写示例：\n    \n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/Uof3pbiB-image.png)\n7. 全部填写好后我们成功创建了一个 Github 授权应用。\n8. 这里需要我们进行几个关键信息的记录，一个是 client_id 这个不会变，一个是 client_secret （注意，这个只能查看一次请妥善保管），这些信息我们后面需要用。\n\n\n\n\n\n\n## 定义一个跳转按钮，进行 Github 的授权\n\n首先在前端页面中定义一个跳转到 Github 授权页面的链接，示例如下：\n\n```html\n<a href=\"https://github.com/login/oauth/authorize?scope=user:email&client_id=请填写自己的client_id\">Github登录</a>\n```\n\n这里可以自己随意快速的开一个前端应用，然后加一个链接标签，把 href 属性的值如上就可以了，只需要注意的是其中的 client_id 需要换成自己的就行，创建好以后，前后端分离的那么前端几乎就没有事情需要做了。这里主要是前后端分离版本。 \n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/8JS3s54W-image.png)\n\n\n\n\n## 通过授权拿到一个随机的 code \n\n点击上面的 Github 登录以后会出现一个这样的页面\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/P5NZegXh-image.png)\n\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/kS3WuVBv-image.png)\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/03ZeCMFZ-image.png)\n\n通过在创建的应用的时候写的回调 URL 进行后端的处理，用户在点击授权以后，页面会重定向进行一个 Get 请求，后端去接收这个请求，并且进行处理就可以了，重定向的时候，会传递一个参数 code ，这个 code 可以用于获取 access_token , 获取到 token 以后用于获取 用户的信息。\n\n接口示例：\n\n```java\npublic class ThirdLoginController {\n    @GetMapping(\"/callback\")\n    public void getCode(String code){\n        System.out.println(code);\n```\n\ndebug 拿值示例\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/AFOIg3OB-image.png)\n\n\n\n这一部分只是为了我能够拿到 code 的值，我们一步一步来，看下面 \uD83D\uDC47\n\n\n\n## 通过 code 进行后端回调处理，拿到access_token\n\n这里我是通过阅读官方文档进行一点一点测试的，官方的文档的语言并不是 Java 这里给出官方文档和我的写法\n\n我的写法(这里发起 Http 请求使用的是 Hutool 工具包)\n\n```java\nMap<String, Object > paramMap = new HashMap<>();\nparamMap.put(\"client_id\",\"填写自己的client_id\");\nparamMap.put(\"client_secret\",\"填写自己的secret\");\nparamMap.put(\"code\",code);\nparamMap.put(\"accept\",\"json\");\nString result = HttpUtil.post(\"https://github.com/login/oauth/access_token\",paramMap);\n```\n\n拿到的结果(类似\uD83D\uDC47)：\n\n```json\naccess_token=gho_lK2Eop11rUH9U7aDTcxUrdORdTPAIS2vVDbh&scope=user%3Aemail&token_type=bearer\n```\n\n\n\n官方参考\n\n```ruby\nget '/callback' do\n  # get temporary GitHub code...\n  session_code = request.env['rack.request.query_hash']['code']\n\n  # ... and POST it back to GitHub\n  result = RestClient.post('https://github.com/login/oauth/access_token',\n                          {:client_id => CLIENT_ID,\n                           :client_secret => CLIENT_SECRET,\n                           :code => session_code},\n                           :accept => :json)\n\n  # extract the token and granted scopes\n  access_token = JSON.parse(result)['access_token']\nend\n```\n\n\n\n## 拿到授权信息以后可以进行获取用户的信息\n\n拿到 token 信息以后，我们要对信息进行处理，从中提取出 access_token 的值，然后就是发起请求获取用户信息了，这里获取用户信息，也是参考官方文档的，后面一直授权不能通过，通过问 AI 解决了问题。\n\n我的示例代码：\n\n```java\n// 处理拿到的信息\nString token = result.split(\"&\")[0].split(\"=\")[1];\n        // 获取用户信息，发起get 请求，拿到用户信息\n        String finalResult = HttpRequest.get(\"https://api.github.com/user\")\n                .header(\"Authorization\",\"token \"+token)\n                .header(\"X-GitHub-Api-Version\", \"2022-11-28\")\n                .execute().body();\n```\n\n> 代码中我出问题的地方在 header 的设置，也就是不知道我获取的 token 怎么传给 github 官方，好像参考的里面说的也不是很明白，后面看了，github 官方关于 授权的文档是要加上两个请求头才能够正常进行请求`Authorization`(这里需要注意的是，token 值得书写，必须是 token后面空格，写access_token的值)   `X-GitHub-Api-Version ` 这个的话就是只需要带上 API 版本的值就好了。\n\n信息结果示例：\n\n```json\n{\n  \"login\": \"xwhking\",\n  \"id\": 97931879,\n  \"node_id\": \"U_kgDOBdZSZw\",\n  \"avatar_url\": \"https://avatars.githubusercontent.com/u/97931879?v=4\",\n  \"gravatar_id\": \"\",\n  \"url\": \"https://api.github.com/users/xwhking\",\n  \"html_url\": \"https://github.com/xwhking\",\n  \"followers_url\": \"https://api.github.com/users/xwhking/followers\",\n  \"following_url\": \"https://api.github.com/users/xwhking/following{/other_user}\",\n  \"gists_url\": \"https://api.github.com/users/xwhking/gists{/gist_id}\",\n  \"starred_url\": \"https://api.github.com/users/xwhking/starred{/owner}{/repo}\",\n  \"subscriptions_url\": \"https://api.github.com/users/xwhking/subscriptions\",\n  \"organizations_url\": \"https://api.github.com/users/xwhking/orgs\",\n  \"repos_url\": \"https://api.github.com/users/xwhking/repos\",\n  \"events_url\": \"https://api.github.com/users/xwhking/events{/privacy}\",\n  \"received_events_url\": \"https://api.github.com/users/xwhking/received_events\",\n  \"type\": \"User\",\n  \"site_admin\": false,\n  \"name\": \"xwhking\",\n  \"company\": null,\n  \"blog\": \"\",\n  \"location\": null,\n  \"email\": null,\n  \"hireable\": null,\n  \"bio\": null,\n  \"twitter_username\": null,\n  \"public_repos\": 8,\n  \"public_gists\": 0,\n  \"followers\": 1,\n  \"following\": 2,\n  \"created_at\": \"2022-01-18T04:06:06Z\",\n  \"updated_at\": \"2024-02-20T02:27:32Z\"\n}\n```\n\n从中我们可以获取一些最为直观的信息，比如 name（github用户名），avatar_url （头像地址），html_url（用户的 github 主页）等。\n\n还可以以同样的方式获取用户的邮箱，只是请求的url 变化一下而且，就是请求 url 变成 `https://api.github.com/user/emails` \n\n请求邮箱结果如下：\n\n```json\n[\n    {\n        \"email\": \"2837468248@qq.com\",\n        \"primary\": true,\n        \"verified\": true,\n        \"visibility\": \"private\"\n    },\n    {\n        \"email\": \"97931879+xwhking@users.noreply.github.com\",\n        \"primary\": false,\n        \"verified\": true,\n        \"visibility\": null\n    }\n]\n```\n\n从中可以获取邮箱信息，通过判断 primary 字段判断是否为私有邮箱。\n\n\n\n参考官方文档：\n\n```ruby\n# fetch user information\nauth_result = JSON.parse(RestClient.get('https://api.github.com/user',\n                                        {:params => {:access_token => access_token}}))\n\n# if the user authorized it, fetch private emails\nif has_user_email_scope\n  auth_result['private_emails'] =\n    JSON.parse(RestClient.get('https://api.github.com/user/emails',\n                              {:params => {:access_token => access_token}}))\nend\n\nerb :basic, :locals => auth_result\n```\n\n\n\n整体的一个后端代码示例：\n\n```java\n@RestController\n@RequestMapping(\"/third_login\")\npublic class ThirdLoginController {\n    @GetMapping(\"/callback\")\n    public void getCode(String code){\n        System.out.println(code);\n        Map<String, Object > paramMap = new HashMap<>();\n        paramMap.put(\"client_id\",\"XXX\");\n        paramMap.put(\"client_secret\",\"XXX\");\n        paramMap.put(\"code\",code);\n        paramMap.put(\"accept\",\"json\");\n        String result = HttpUtil.post(\"https://github.com/login/oauth/access_token\",paramMap);\n        String token = result.split(\"&\")[0].split(\"=\")[1];\n        // 获取用户信息\n        String finalResult = HttpRequest.get(\"https://api.github.com/user\")\n                .header(\"Authorization\",\"token \"+token)\n                .header(\"X-GitHub-Api-Version\", \"2022-11-28\")\n                .execute().body();\n        System.out.println(finalResult);\n\n    }\n}\n```\n\n\n\n\n\n## 拿到的用户信息与数据库进行比对进行登录验证（思路）\n\n我们都拿到 Github 上用户的信息了，那么只需要把拿到的信息放入我们自己的数据库，那么是不是就可以让用户进行登录了呀！\n\n\n\n比如我们可以记录用户的，id，用户名，邮箱，如果用户是第一次登录，就新创建一条记录，如果不是就进行数据库数据的比对进行登录，如果有错误，不让登录就好。没有错误就把页面重定向到对应的前端页面，并且把用户信息返回给前端。这样应该就算是第三方登录了吧！ ",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 36,
        "thumbNum": 2,
        "favourNum": 2,
        "commentNum": 0,
        "priority": 0,
        "userId": "1645799822881509377",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-21T04:10:02.000+00:00",
        "updateTime": "2024-02-26T13:23:40.000+00:00",
        "user": {
          "id": "1645799822881509377",
          "planetCode": "14255",
          "userName": "为",
          "userAvatar": null,
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-10-01T13:19:43.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-04-11T14:43:49.000+00:00",
          "updateTime": "2024-01-30T06:21:10.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "GitHub"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1759507966932934658",
        "title": "从聚合搜索项目视角入门Elasticsearch（搜索引擎、对比MongoDB、聚合搜索流程具体实现…）",
        "description": "通过对比MongoDB、分析聚合搜索项目核心流程、分析搜索引擎基本原理、Elastic Stack等思考进一步了解和入门Elasticsearch",
        "content": "\n\n![oUviN.png](https://i0.imgs.ovh/2024/02/18/oUviN.png)\n\n在学完聚合搜索项目后，笔者对**Elasticsearch**（下称ES）的基本语法和应用流程有了较为全面的了解、学习和掌握，同时因为之前了解过MongoDB、搜索引擎的基本原理，因此有了一些思考，如下：\n\n> 1. Elastic Stack 这一套技术栈包括的内容？\n> 2. 做聚合搜索时，可以用ES实现哪些实用功能？\n> 3. 同样支持倒排索引，对比MongoDB，ES的优势是什么？\n> 4. 搜索引擎的流程是什么，ES可以在哪个环节进行参与？\n> 5. 在聚合搜索这个项目中，涉及ES的流程的具体实现使用的技术分别有哪些？\n\n愚以为这些思考，有助于进一步认识ES，并希望通过这些思考，能够对聚合搜索（或搜索引擎）的实现流程，有一个具体实现的方案和思路。以下就是对于以上思考的答案，也希望能对读者有一定启发作用。\n\n# 一、Elastic Stack 这一套技术栈包括的内容\n\n官网：https://www.elastic.co/cn/\n包含了数据的整合 => 提取 => 存储 => 使用，一整套。\n\n**Elastic Stack 是一个开源的数据分析平台，主要用于实时搜索、分析和可视化大规模的结构化和非结构化数据**。它包含以下主要组件：\n\n1.  **Elasticsearch**：这是 Elastic Stack 的核心组件，一个分布式的实时搜索和分析引擎。Elasticsearch 负责存储、搜索和分析数据，并提供 RESTful API 以进行数据索引和查询。 \n2.  **Logstash**：Logstash 是一个用于数据收集、转换和发送的数据处理管道工具。它可以从多种来源（如日志文件、消息队列、数据库等）收集数据，然后进行过滤、转换和标准化，最后将数据发送到 Elasticsearch 等目标存储或分析系统。 \n3.  **Kibana**：Kibana 是 Elastic Stack 的可视化平台，用于分析和可视化 Elasticsearch 中的数据。它提供了丰富的图表、图形和仪表板，用户可以通过 Kibana 轻松地创建定制化的数据可视化和仪表板，并进行数据分析和探索。 \n4.  **Beats**：Beats 是一组轻量级的数据收集器，用于收集各种类型的操作数据，并将其发送到 Elasticsearch 或 Logstash 进行处理和存储。Beats 包括多个模块，如 Filebeat 用于收集日志文件、Metricbeat 用于收集系统和服务指标、Packetbeat 用于网络数据分析等。 \n\n这些组件共同构成了 Elastic Stack，使用户能够以高效、灵活和可扩展的方式收集、存储、搜索、分析和可视化数据。\n\n\n\n# 二、做聚合搜索时，可以通过ES实现哪些实用功能？\n\n## 1. 通过text、keyword字段分别实现模糊查询和精确查询\n\n当在 Elasticsearch 中设置索引的映射（mapping）时，如果字段的类型被定义为 text，Elasticsearch 会默认将这些字段纳入倒排索引中。\n\n**倒排索引（Inverted Index）**是 Elasticsearch 用于实现全文搜索功能的核心数据结构之一。它将每个文档中的所有单词（或者称为词条、术语）映射到包含该单词的文档列表上。这样的索引结构使得 Elasticsearch 能够快速地进行文本搜索。\n\n对于 text 类型的字段，Elasticsearch 会将文本数据分析成单词，然后将这些单词存储在倒排索引中。这样做的好处是，用户可以通过搜索查询中的单词来查找包含这些单词的文档，而不必考虑单词的顺序或大小写等问题。\n\n需要注意的是，对于需要进行精确匹配或排序的字段，通常会将字段类型定义为 keyword 类型，而不是 text 类型。keyword 类型的字段不会被纳入倒排索引中，而是以精确值进行索引，适用于需要进行精确匹配或聚合操作的场景。\n\n------\n\n**其中，关于倒排索引：**\n\n当你在搜索引擎中进行一个查询时，比如输入了一个关键词，搜索引擎会迅速地找到所有包含这个关键词的文档。这样的速度是怎么实现的呢？这就是倒排索引发挥作用的地方。\n\n假设有一个包含了大量文档的数据库，每个文档都有一些关键词。倒排索引是一种将这些关键词映射到文档的数据结构，它的原理如下：\n\n1.  **收集关键词**：首先，对于每个文档，搜索引擎会分析其内容，将关键词提取出来。这可能包括分词（将文本分成一个个单词）、去除停用词（例如 \"the\", \"a\", \"an\" 等）和其他文本预处理操作。 \n2.  **建立映射**：然后，对于每个关键词，搜索引擎会建立一个映射，将该关键词与包含该关键词的文档列表关联起来。这个过程叫做建立倒排索引。 \n3.  **搜索过程**：当你输入一个查询时，搜索引擎会立即查找包含这个查询关键词的文档列表。这个过程非常迅速，因为搜索引擎只需简单地查找这个关键词在倒排索引中的条目，然后返回与之相关联的文档列表。 \n\n倒排索引的优点在于它的查询速度非常快，因为它不需要遍历整个文档集合，而只需查找倒排索引中的条目。此外，倒排索引还支持高级搜索功能，比如短语匹配、布尔搜索等。\n\n举个例子，假设有一个包含了多篇文章的数据库。当你搜索 \"Elasticsearch\" 时，倒排索引可以立即告诉搜索引擎哪些文章包含了 \"Elasticsearch\"，而不需要搜索引擎逐篇逐句地查找。这样就能极大地加速搜索过程。\n\n------\n\n同时，**倒排索引**是一个需要维护的数据结构。在搜索引擎中，当有新的文档被索引、已有文档被修改或删除时，都会触发倒排索引的更新操作。\n\n具体来说，当有新的文档被索引时，搜索引擎会分析文档内容并提取关键词，然后将这些关键词与文档的标识（如文档 ID）建立映射关系，并将这些映射关系添加到倒排索引中。这样就能在搜索时快速找到包含这些关键词的文档。\n\n当已有文档被修改或删除时，搜索引擎也会相应地更新倒排索引。如果修改操作导致文档内容发生变化，那么搜索引擎需要重新分析文档内容，并更新倒排索引中与该文档相关的条目。如果文档被删除，搜索引擎则需要从倒排索引中移除与该文档相关的条目。\n\n**倒排索引的维护是搜索引擎索引更新的关键部分**，它确保了搜索引擎能够及时准确地响应用户的搜索请求，并保持搜索性能的稳定性。虽然倒排索引的维护会带来一定的计算和存储开销，但**这是搜索引擎能够高效工作的基础**。\n\n------\n\n在 Elasticsearch 中，每个索引都有自己的倒排索引，因此不同的索引中的同名字段会分别构建不同的倒排索引。所以，如果你有两个不同的索引，它们都包含了同名的 `text` 类型字段，那么每个索引会分别构建自己的倒排索引表。\n\n当用户按照这个字段进行查询时，Elasticsearch 会在每个索引的倒排索引表中进行搜索，并返回匹配的结果。换句话说，两个不同的索引中的同名字段数据会分别被检索，并且用户会得到包含了这两个索引中相关数据的搜索结果。\n\n如果你希望将两个不同索引中同名字段的数据合并在一起进行搜索，你可以使用 Elasticsearch 提供的多索引搜索功能，或者在查询时指定多个索引。这样 Elasticsearch 就会在多个索引的倒排索引表中进行搜索，并将结果合并返回给用户。\n\n------\n\n在**收集关键词阶段**，搜索引擎可以使用分词器来对文档内容进行分词处理，以提取出关键词。\n\n对于中文文档而言，常用的分词器包括 IK Analyzer、Jieba 分词器等。这些分词器能够根据中文语言的特点将文本分成一个个单词或词语，并且会考虑到词义、停用词等因素，以提高搜索的准确性和效率。\n\n例如，IK Analyzer 是一个常用的中文分词器，它能够根据中文语法规则将文本分成有意义的词语，同时过滤掉停用词（如 \"的\"、\"了\"、\"是\" 等），从而提高搜索的精确度。\n\n因此，在处理中文文档时，使用合适的分词器对文本进行分词处理是非常重要的，能够有效地提取出关键词，为搜索引擎的后续操作提供准确的数据。\n\n------\n\n示例表结构（DSL语法）\n\n```json\nPOST post_v1\n{\n  \"aliases\": {\n    \"post\": {}\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"title\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\",\n        \"search_analyzer\": \"ik_smart\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          }\n        }\n      },\n      \"content\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\",\n        \"search_analyzer\": \"ik_smart\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          }\n        }\n      },\n      \"tags\": {\n        \"type\": \"keyword\"\n      },\n      \"userId\": {\n        \"type\": \"keyword\"\n      },\n      \"createTime\": {\n        \"type\": \"date\"\n      },\n      \"updateTime\": {\n        \"type\": \"date\"\n      },\n      \"isDelete\": {\n        \"type\": \"keyword\"\n      }\n    }\n  }\n}\n```\n\n\n\n## 2. 搜索建议\n\nElasticsearch 提供了搜索建议（Search Suggest）功能，它能够根据用户输入的搜索查询词，实时地提供搜索建议或自动完成功能，帮助用户更快速地找到他们感兴趣的内容。这个功能通常被用于搜索框下拉列表中，以帮助用户在输入查询时快速获得相关的搜索建议。\n\n在 Elasticsearch 中，搜索建议功能主要通过两种方式实现：\n\n1.  **完全匹配建议（Term Suggester）**：这种建议是基于用户输入的查询词的拼写或输入错误进行纠正和完全匹配的。Elasticsearch 使用一种称为编辑距离（Edit Distance）的算法来识别和纠正输入中的拼写错误，并提供与纠正后的查询词相匹配的建议。 \n2.  **上下文建议（Context Suggester）**：这种建议是根据用户输入的上下文信息（如用户的搜索历史、用户的地理位置、用户的偏好等）来提供与上下文相关的搜索建议。Elasticsearch 可以使用上下文信息来过滤搜索建议，以提供更加个性化和有针对性的搜索建议。 \n\n要使用搜索建议功能，通常需要创建一个索引并在索引中定义一个或多个搜索建议器。搜索建议器定义了搜索建议的类型和规则，并且可以根据需求进行配置和调优。一旦搜索建议器被创建，就可以通过 Elasticsearch 提供的搜索建议 API 来获取搜索建议并将其显示在用户界面上。\n\n总的来说，搜索建议功能能够提升用户搜索体验，让用户更加方便快捷地找到他们感兴趣的内容，从而提高了搜索系统的可用性和用户满意度。\n\n------\n\n当使用 Elasticsearch 的搜索建议功能时，您可以根据不同的需求选择使用完全匹配建议、上下文建议或它们的组合。以下是针对每种情况的示例：\n\n### 2.1. 单独使用完全匹配建议（Term Suggester）：\n\n```json\nPOST /my_index/_search\n{\n  \"suggest\": {\n    \"my_suggestion\": {\n      \"text\": \"搜索建议示例\", \n      \"term\": {\n        \"field\": \"suggest_field\" \n      }\n    }\n  }\n}\n```\n\n在这个示例中，我们使用了 `\"term\"` 类型的建议器，表示要执行的是基于完全匹配的建议。这会返回与用户输入的查询词相匹配的建议结果，用于纠正用户输入的拼写错误或提供自动完成功能。\n\n### 2.2. 单独使用上下文建议（Context Suggester）：\n\n```json\nPOST /my_index/_search\n{\n  \"suggest\": {\n    \"my_suggestion\": {\n      \"text\": \"搜索建议示例\", \n      \"context\": {\n        \"location\": {\n          \"lat\": 40.73,\n          \"lon\": -74.1\n        }\n      },\n      \"completion\": {\n        \"field\": \"suggest_field\" \n      }\n    }\n  }\n}\n```\n\n\n\n在这个示例中，我们在搜索建议器中同时使用了 `\"completion\"` 类型和 `\"context\"` 参数，表示要执行的是基于上下文的建议。通过配置不同的上下文参数，例如用户的地理位置、搜索历史等，可以过滤和定制搜索建议的结果，使其更加个性化和有针对性。\n\n在 Elasticsearch 中，上下文建议（Context Suggester）允许您根据用户的上下文信息来定制搜索建议的结果。其中，\"context\" 参数用于指定上下文信息，以过滤和定制搜索建议的结果。\n\n在您提供的示例中，\"location\" 上下文参数指定了用户的地理位置信息，包括经纬度。这样，您可以根据用户的地理位置来调整搜索建议的结果，以确保返回的建议与用户所在位置相关联。\n\n举例来说，假设您正在为一个手机应用开发地理位置服务，用户正在输入搜索查询词 \"餐厅\"。通过提供用户的地理位置信息，您可以定制搜索建议的结果，使其返回附近的餐厅名称或地址，从而帮助用户更方便地找到附近的餐厅。\n\n总的来说，\"context\" 参数允许您根据用户的上下文信息来定制搜索建议的结果，以提供更加个性化和有针对性的搜索体验。\n\n### 2.3. 综合使用完全匹配和上下文建议：\n\n```json\nPOST /my_index/_search\n{\n  \"suggest\": {\n    \"my_suggestion\": {\n      \"text\": \"搜索建议示例\", \n      \"term\": {\n        \"field\": \"suggest_field\" \n      },\n      \"context\": {\n        \"location\": {\n          \"lat\": 40.73,\n          \"lon\": -74.1\n        }\n      }\n    }\n  }\n}\n```\n\n在这个示例中，我们在搜索建议器中同时使用了完全匹配建议和上下文建议。这意味着搜索建议结果将同时考虑用户输入的查询词以及用户的上下文信息，以提供更加准确和有针对性的搜索建议。\n\n\n\n## 3. 搜索高亮\n\nElasticsearch 的搜索高亮功能允许您在搜索结果中突出显示匹配搜索条件的部分，以提高用户的搜索体验和结果的可读性。当用户进行全文搜索时，高亮功能可以使匹配的关键词在搜索结果中更加显眼，帮助用户快速定位到相关内容。\n\n搜索高亮功能的实现原理是在搜索结果中将匹配搜索条件的文本片段用指定的标记进行包裹，例如 `<em>` 标签，以标识出这部分文本是搜索条件的匹配结果。这样，在搜索结果中就可以直观地看到哪些部分是与搜索条件匹配的，从而让用户更容易理解搜索结果。\n\n以下是一个示例，演示如何在 Elasticsearch 中使用搜索高亮功能：\n\n```json\nPOST /my_index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"content\": \"关键词\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"content\": {}\n    }\n  }\n}\n```\n\n在这个示例中：\n\n- `\"query\"` 部分指定了要执行的搜索查询，这里使用了简单的匹配查询，匹配字段 \"content\" 中包含 \"关键词\" 的文档。\n- `\"highlight\"` 部分指定了要对哪些字段进行高亮处理，这里指定了字段 \"content\"。\n- 通过执行这个查询，Elasticsearch 将会返回搜索结果，并将匹配 \"关键词\" 的部分用指定的标记进行高亮显示。\n\n您可以通过配置不同的高亮参数，例如指定高亮标记的类型、定制高亮标记的样式等，以满足不同的需求和场景。\n\n总的来说，搜索高亮功能是 Elasticsearch 中一个非常实用的功能，能够提高搜索结果的可读性和用户体验，帮助用户更加快速地找到他们感兴趣的内容。\n\n------\n\n例如，可以指定其他标签作为搜索结果高亮的标记，而不仅限于 `<em>` 标签。在 Elasticsearch 中，您可以通过设置 `\"pre_tags\"` 和 `\"post_tags\"` 参数来指定高亮的起始标记和结束标记。\n\n以下是一个示例，演示如何在 Elasticsearch 中使用自定义标记进行搜索结果高亮：\n\n```json\nPOST /my_index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"content\": \"关键词\"\n    }\n  },\n  \"highlight\": {\n    \"pre_tags\": [\"<strong>\"],\n    \"post_tags\": [\"</strong>\"],\n    \"fields\": {\n      \"content\": {}\n    }\n  }\n}\n```\n\n在这个示例中，我们使用了 `<strong>` 标签作为高亮的起始标记，`</strong>` 标签作为高亮的结束标记。这样，在搜索结果中匹配到的文本片段就会被 `<strong>` 和 `</strong>` 标签包裹起来，以标识出匹配的部分。\n\n可以根据需要自定义任何标记来标识搜索结果的高亮部分，以适应您的应用场景和样式需求。\n\n\n\n# 三、同样支持倒排索引，对比MongoDB，ES的优势是什么？\n\nElasticsearch（ES）和MongoDB都是流行的数据存储和检索解决方案，但它们在设计目标、特点和适用场景上有所不同。以下是 Elasticsearch 相对于 MongoDB 的一些优势：\n\n1.  **全文搜索功能：** Elasticsearch 是一个专门用于全文搜索和分析的搜索引擎，具有强大的全文搜索和分析功能，支持复杂的搜索查询、聚合分析和搜索建议等功能。相比之下，MongoDB 虽然也支持文本搜索，但其功能相对较弱。 \n2.  **分布式性能和可扩展性：** Elasticsearch 是一个分布式系统，具有良好的水平扩展性和高可用性。它可以轻松地处理大规模数据集和高并发请求，并能够通过添加更多的节点来实现横向扩展。MongoDB 也支持分片和副本集等方式来实现水平扩展，但相比之下，Elasticsearch 在分布式性能和扩展性方面更为出色。 \n3.  **实时索引和搜索：** Elasticsearch 提供了近实时（Near Real-Time）的索引和搜索功能，即当新的文档被索引时，它们几乎立即就可以被搜索到。这使得 Elasticsearch 在需要实时索引和搜索的应用场景下具有明显的优势。MongoDB 也支持实时索引和搜索，但相比之下，Elasticsearch 的实时性能更好。 \n4.  **复杂的聚合和分析：** Elasticsearch 提供了丰富的聚合和分析功能，可以对大规模数据集进行复杂的数据分析和聚合操作。它支持多种聚合操作，如分组聚合、统计聚合、日期直方图聚合等，能够快速地对数据进行深入分析。MongoDB 也支持聚合框架来执行复杂的数据分析，但 Elasticsearch 在聚合和分析功能方面更加强大和灵活。 \n5.  **全文检索与结构化数据的融合：** Elasticsearch 可以同时处理全文检索和结构化数据，使得开发人员可以在同一个平台上完成文本搜索和结构化数据的存储和检索操作。相比之下，MongoDB 更偏向于结构化数据的存储和查询，全文搜索功能相对有限。 \n\n综上所述，Elasticsearch 在全文搜索、分布式性能、实时索引和搜索、复杂的聚合分析等方面具有明显的优势，特别适用于需要高性能全文搜索和复杂数据分析的应用场景。而 MongoDB 则更适用于对结构化数据进行存储和查询的应用场景。\n\n## 1. 应用场景\n\nMongoDB 和 Elasticsearch（ES）都是强大的数据存储和检索工具，但它们的设计目标和特点不同，适用于不同的应用场景。以下是它们各自的主要应用场景：\n\n### 1.1. MongoDB 的主要应用场景\n\n1.  **大部分操作是基于数据的 CRUD 操作：** MongoDB 适合于大部分操作是基于数据的增删改查操作的应用场景，例如 Web 应用的后端数据库、内容管理系统（CMS）、博客平台等。 \n2.  **需要灵活的数据模型：** MongoDB 是一种 NoSQL 数据库，支持灵活的数据模型，能够存储半结构化或非结构化的数据，因此适用于需要频繁更改数据模式的应用场景。 \n3.  **需要高性能和可扩展性：** MongoDB 具有良好的性能和可扩展性，能够轻松地处理大规模数据和高并发请求。它支持分片和副本集等方式来实现水平扩展，因此适用于需要高性能和可扩展性的应用场景。 \n4.  **实时数据分析和报表生成：** MongoDB 支持丰富的聚合操作和数据分析功能，能够快速地对数据进行聚合和分析，因此适用于实时数据分析和报表生成的应用场景。 \n\n### 1.2. Elasticsearch 的主要应用场景\n\n1.  **全文搜索和分析：** Elasticsearch 是一个专门用于全文搜索和分析的搜索引擎，适用于需要高效全文搜索和分析功能的应用场景，例如搜索引擎、日志分析、文档管理系统等。 \n2.  **需要复杂的搜索查询和聚合分析：** Elasticsearch 提供了丰富的查询操作和聚合操作，能够执行复杂的搜索查询和数据分析，因此适用于需要复杂搜索查询和聚合分析功能的应用场景。 \n3.  **需要实时索引和搜索：** Elasticsearch 提供近实时的索引和搜索功能，能够快速地索引新的文档并进行搜索，因此适用于需要实时索引和搜索功能的应用场景，例如实时日志分析、监控系统等。 \n4.  **需要高性能和可扩展性：** Elasticsearch 具有良好的性能和可扩展性，能够轻松地处理大规模数据和高并发请求，适用于需要高性能和可扩展性的应用场景。 \n\n总的来说，MongoDB 适用于大部分操作是基于数据的 CRUD 操作、需要灵活的数据模型和需要高性能和可扩展性的应用场景，而 Elasticsearch 适用于需要高效全文搜索和分析功能、复杂的搜索查询和聚合分析功能以及需要实时索引和搜索功能的应用场景。\n\n## 2. 全文匹配\n\n当涉及到全文搜索和倒排索引功能时，MongoDB 和 Elasticsearch（ES）有着不同的实现方式和特点。下面将分别介绍它们的倒排索引全文匹配功能，然后进行详细比较：\n\n### 2.1. MongoDB 的全文匹配功能\n\nMongoDB 的全文搜索功能通过全文索引实现，它使用文本索引来支持文本字段的全文搜索。MongoDB 的全文索引支持文本查询操作，如 `$text` 查询操作符和 `$search` 查询操作符。您可以在文本字段上创建文本索引，并使用 `$text` 查询操作符来执行全文搜索查询。\n\n下面是 MongoDB 全文搜索的示例：\n\n```javascript\ndb.articles.createIndex({ content: \"text\" });\n\n// 查询包含关键词 \"Elasticsearch\" 的文档\ndb.articles.find({ $text: { $search: \"Elasticsearch\" } });\n```\n\n### 2.2. Elasticsearch 的全文匹配功能\n\nElasticsearch 是专门用于全文搜索和分析的搜索引擎，它使用倒排索引和分析器来实现全文搜索功能。在 Elasticsearch 中，您可以针对文本字段定义自定义的分析器（Analyzer），以便对文本进行分词和处理，并使用倒排索引来存储和快速检索文本数据。\n\n下面是 Elasticsearch 全文搜索的示例：\n\n```json\nPOST /articles/_search\n{\n  \"query\": {\n    \"match\": {\n      \"content\": \"Elasticsearch\"\n    }\n  }\n}\n```\n\n### 2.3. MongoDB 和 Elasticsearch 的全文搜索功能比较\n\n1.  **实现方式：** MongoDB 使用全文索引来支持全文搜索，而 Elasticsearch 则使用倒排索引和分析器来实现全文搜索。 \n2.  **功能丰富程度：** Elasticsearch 的全文搜索功能更加丰富和灵活，支持更多的查询类型、聚合操作和搜索建议功能等。MongoDB 的全文搜索功能相对较简单，支持的操作和功能较少。 \n3.  **性能和扩展性：** Elasticsearch 在全文搜索性能和扩展性方面更具优势，特别是在大规模数据集和高并发请求的场景下，其性能和扩展性表现更好。 \n4.  **实时性：** Elasticsearch 提供近实时的索引和搜索功能，能够快速地索引新的文档并进行搜索，而 MongoDB 的全文索引需要在后台进行后台构建和维护，可能不如 Elasticsearch 实时。 \n\n\n\n综上所述，虽然 MongoDB 也提供了全文搜索功能，但相比之下，Elasticsearch 更适用于需要强大全文搜索功能的应用场景，特别是在需要高性能、实时性和灵活性的场景下，Elasticsearch 是更好的选择。\n\n\n\n## 3. 全文搜索\n\n详细地对比一下 MongoDB 和 Elasticsearch 的全文搜索功能，包括是否支持分词、定制化插件等方面的细节。\n\n### 3.1. MongoDB 的全文搜索功能\n\n1.  **支持分词：** MongoDB 的全文搜索功能基于文本索引实现，它会在创建文本索引时将文本字段的内容进行分词处理。MongoDB 支持基于分词后的词语进行查询匹配。 \n2.  **分词器：** MongoDB 内置了一个简单的分词器，用于对文本进行基本的分词处理。然而，MongoDB 不支持像 Elasticsearch 那样灵活地定制分词器或使用第三方分词器。 \n\n### 3.2. Elasticsearch 的全文搜索功能\n\n1.  **支持分词：** Elasticsearch 使用分词器（Analyzer）对文本进行分词处理，可以将文本字段分割成独立的词语进行索引和搜索。Elasticsearch 支持多种内置的分词器，例如 Standard 分词器、Simple 分词器、Whitespace 分词器等。 \n2.  **定制化插件：** Elasticsearch 允许用户通过定制化插件来扩展和定制分词器。用户可以根据自己的需求使用自定义分词器，例如 IK Analyzer、Smart Chinese Analysis 等，来适应不同语言的分词需求。 \n3.  **支持多语言：** Elasticsearch 支持多种语言的分词处理，包括中文、英文、法文、德文等。用户可以根据需要选择合适的分词器进行配置。 \n4.  **复杂查询：** Elasticsearch 提供了丰富的查询操作和查询语法，支持复杂的全文搜索和过滤条件。用户可以使用各种查询操作符和组合条件来执行复杂的全文搜索查询。 \n\n### 3.3. 比较\n\n-  **分词支持：** Elasticsearch 提供了更加灵活和强大的分词支持，允许用户使用各种内置和定制化分词器来满足不同语言和需求的分词需求。 \n-  **定制化插件：** Elasticsearch 允许用户使用定制化插件来扩展和定制分词器，使得用户能够根据具体需求选择合适的分词器。 \n-  **复杂性和灵活性：** Elasticsearch 在全文搜索功能的复杂性和灵活性方面更具优势，支持更多的查询操作、聚合操作和搜索建议功能等。 \n\n\n\n总的来说，虽然 MongoDB 也提供了基本的全文搜索功能，但相比之下，Elasticsearch 在分词支持、定制化插件和搜索功能的复杂性和灵活性方面更具优势，特别适用于需要强大全文搜索功能的应用场景。\n\n\n\n# 四、搜索引擎的流程是什么，ES可以在哪个环节进行参与？\n\n## 1. 搜索引擎\n\n有关搜索引擎可参考此文章：https://mp.weixin.qq.com/s/zn-SvUN5E4WWQhs88ienzQ\n\n![oiPkp.gif](https://i0.imgs.ovh/2024/02/18/oiPkp.gif)\n\n### 1.1. 第 1 步 - 抓取\n\n网络爬虫会在互联网上扫描网页。它们跟踪从一个页面到另一个页面的 URL 链接，并将 URL 存储在 URL 存储器中。爬虫会发现新的内容，包括网页、图片、视频和文件。\n\n### 1.2. 第 2 步 - 编制索引\n\n网页被抓取后，搜索引擎会对网页进行解析，并将网页上的内容编入索引数据库。对内容进行分析和分类。例如，评估关键字、网站质量、内容新鲜度和许多其他因素，以了解网页的内容。\n\n### 1.3. 第 3 步 - 排名\n\n搜索引擎使用复杂的算法来决定搜索结果的顺序。这些算法会考虑各种因素，包括关键词、页面相关性、内容质量、用户参与度、页面加载速度等。有些搜索引擎还会根据用户过去的搜索历史、位置、设备和其他个人因素对搜索结果进行个性化处理。\n\n### 1.4. 第 4 步 - 查询\n\n当用户执行搜索时，搜索引擎会筛选其索引，以提供最相关的结果。\n\n\n\n## 2. ES的作用\n\n在第 2 步 - 编制索引中，ES可以作为索引数据库，在后续第4步用户执行搜索时，提供搜索服务。\n\n在第 3 步 - 排名中，ES的查询结果中的相关度得分可作为最终排名的参考之一。\n\n具体而言，Elasticsearch 的查询结果包含每个文档的相关度得分（score），用于衡量文档与查询的匹配程度。得分越高表示文档与查询的匹配程度越高，排名越靠前。\n\n下面是一个简单的示例，说明 Elasticsearch 查询结果中的得分字段：\n\n假设我们有一个名为 \"articles\" 的索引，其中存储了一些文章数据，我们想要搜索标题（title）字段中包含关键词 \"Elasticsearch\" 的文档，并获取其相关度得分。我们可以使用如下的查询：\n\n```json\nPOST /articles/_search\n{\n  \"query\": {\n    \"match\": {\n      \"title\": \"Elasticsearch\"\n    }\n  }\n}\n```\n\n查询结果中会包含每个文档的相关度得分，例如：\n\n```json\n{\n  \"took\": 10,\n  \"hits\": {\n    \"total\": {\n      \"value\": 2,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 0.6931472,  // 最高得分\n    \"hits\": [\n      {\n        \"_index\": \"articles\",\n        \"_type\": \"_doc\",\n        \"_id\": \"1\",\n        \"_score\": 0.6931472,  // 文档的得分\n        \"_source\": {\n          \"title\": \"Introduction to Elasticsearch\"\n        }\n      },\n      {\n        \"_index\": \"articles\",\n        \"_type\": \"_doc\",\n        \"_id\": \"2\",\n        \"_score\": 0.2876821,  // 文档的得分\n        \"_source\": {\n          \"title\": \"Getting Started with Elasticsearch\"\n        }\n      }\n    ]\n  }\n}\n```\n\n在上面的查询结果中，每个文档都有一个 \"_score\" 字段，表示其相关度得分。得分最高的文档排名最靠前。\n\n------\n\n在 Elasticsearch 中，文档的相关度得分（score）是根据文档与查询的匹配程度来计算的，得分越高表示文档与查询的匹配程度越高。Elasticsearch 使用 TF-IDF 算法和向量空间模型（Vector Space Model）来计算文档的相关度得分。\n\n下面是相关度得分的计算方式和标准：\n\n1.  **TF（Term Frequency，词频）：** 计算查询词在文档中出现的频率，即查询词在文档中出现的次数。词频越高，得分越高。 \n2.  **IDF（Inverse Document Frequency，逆文档频率）：** 计算查询词在整个索引中出现的频率，即查询词在多少个文档中出现过。逆文档频率越低，表示查询词越常见，相关度得分越低。 \n3.  **字段长度归一化：** 对于较长的字段，文档的相关度得分会被字段长度归一化，以避免较长的字段对相关度得分的影响过大。 \n4.  **字段权重调整：** Elasticsearch 支持对不同字段设置不同的权重（boost），可以通过字段权重来调整字段在计算得分时的重要性。 \n5.  **BM25 算法（Best Matching 25）：** Elasticsearch 默认使用 BM25 算法来计算文档的相关度得分，BM25 算法是一种改进的 TF-IDF 算法，考虑了词频和逆文档频率之间的平衡，并且对较长的字段有较好的适应性。 \n\n总的来说，Elasticsearch 使用复杂的算法和模型来计算文档的相关度得分，以确保搜索结果的准确性和相关性。得分越高的文档越接近查询的意图，排名越靠前。\n\n\n\n# 五、在聚合搜索这个项目中，涉及ES的流程的具体实现使用的技术分别有哪些？\n\n## 1. 数据抓取\n\n在聚合搜索这个项目中，数据的类型主要有两种：数据库表数据和网络图片数据（必应）。因此，对应的数据抓取方式也有两种：\n\n1. 数据库数据：使用ChatGPT来生成insert的SQL语句\n2. 网络图片数据：使用爬虫技术，如java使用jsoup库，python使用bs4库。\n\n## 2. 表结构设置和监控\n\n表结构设计基本是使用ES的DSL语法，设置Mapping结构：\n\n```json\nPOST post_v1\n{\n  \"aliases\": {\n    \"post\": {}\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"title\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\",\n        \"search_analyzer\": \"ik_smart\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          }\n        }\n      },\n      \"content\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\",\n        \"search_analyzer\": \"ik_smart\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          }\n        }\n      },\n      \"tags\": {\n        \"type\": \"keyword\"\n      },\n      \"userId\": {\n        \"type\": \"keyword\"\n      },\n      \"createTime\": {\n        \"type\": \"date\"\n      },\n      \"updateTime\": {\n        \"type\": \"date\"\n      },\n      \"isDelete\": {\n        \"type\": \"keyword\"\n      }\n    }\n  }\n}\n```\n\n执行DSL语句和可视化es数据看板，则使用Kibana。\n\n## 3. 数据同步\n\n一般情况下，如果做查询搜索功能，使用 ES 来模糊搜索，但是数据是存放在数据库 MySQL 里的，所以说我们需要把 MySQL 中的数据和 ES 进行同步，保证数据一致（以 MySQL 为主）。\nMySQL => ES （单向）\n首次安装完 ES，把 MySQL 数据全量同步到 ES 里，写一个单次脚本\n**4 种方式**，全量同步（首次）+ 增量同步（新数据）：\n\n1. **定时任务**，比如 1 分钟 1 次，找到 MySQL 中过去几分钟内（至少是定时周期的 2 倍）发生改变的数据，然后更新到 ES。\n   优点：简单易懂、占用资源少、不用引入第三方中间件\n   缺点：有时间差\n   应用场景：数据短时间内不同步影响不大、或者数据几乎不发生修改\n2. **双写**：写数据的时候，必须也去写 ES；更新删除数据库同理。（事务：建议先保证 MySQL 写成功，如果 ES 写失败了，可以通过定时任务 + 日志 + 告警进行检测和修复（补偿））\n3.  用 **Logstash** 数据同步管道（一般要配合 kafka 消息队列 + beats 采集器）\n4.  **Canal** 监听 MySQL Binlog，实时同步\n\n## 4. 客户端调用和查询（Java）\n\n**第一种方式**：ElasticsearchRepository<PostEsDTO, Long>，默认提供了简单的增删改查，多用于可预期的、相对没那么复杂的查询、自定义查询，返回结果相对简单直接。\n接口代码：\n\n```java\npublic interface CrudRepository<T, ID> extends Repository<T, ID> {\n    <S extends T> S save(S entity);\n\n    <S extends T> Iterable<S> saveAll(Iterable<S> entities);\n\n    Optional<T> findById(ID id);\n\n    boolean existsById(ID id);\n\n    Iterable<T> findAll();\n\n    Iterable<T> findAllById(Iterable<ID> ids);\n\n    long count();\n\n    void deleteById(ID id);\n\n    void delete(T entity);\n\n    void deleteAllById(Iterable<? extends ID> ids);\n\n    void deleteAll(Iterable<? extends T> entities);\n\n    void deleteAll();\n}\n```\n\n\nES 中，_开头的字段表示系统默认字段，比如 _id，如果系统不指定，会自动生成。但是不会在 _source 字段中补充 id 的值，所以建议大家手动指定。\n支持根据方法名自动生成方法，比如：\n\n```java\nList<PostEsDTO> findByTitle(String title);\n```\n\n\n\n**第二种方式**：Spring 默认给我们提供的操作 es 的客户端对象 ElasticsearchRestTemplate，也提供了增删改查，它的增删改查更灵活，适用于更复杂的操作，返回结果更完整，但需要自己解析。\n**对于复杂的查询，建议用第二种方式。**\n三个步骤：\n\n**第二种方式**：Spring 默认给我们提供的操作 es 的客户端对象 ElasticsearchRestTemplate，也提供了增删改查，它的增删改查更灵活，适用于更复杂的操作，返回结果更完整，但需要自己解析。\n**对于复杂的查询，建议用第二种方式。**\n三个步骤：\n\n1. 取参数\n2. 把参数组合为 ES 支持的搜索条件\n3. 从返回值中取结果\n\n## 5. 压力测试\n\n官方文档：https://jmeter.apache.org/\n找到 jar 包：apache-jmeter-5.5\\apache-jmeter-5.5\\bin\\ApacheJMeter.jar 启动\n配置线程组 => 请求头 => 默认请求 => 单个请求 => 响应断言 => 聚合报告 / 结果树\n![a7e8e39e1faa38fa51b0d0f55e197695.png](https://i.miji.bid/2024/02/19/a7e8e39e1faa38fa51b0d0f55e197695.png)\n\n99%分位：99%的用户都在这个响应时间内\n吞吐量：每秒处理的请求数 qps\n\n------\n\n压力测试（Stress Testing）是一种评估系统在负载增加的情况下性能表现的方法。进行压力测试的主要目的是发现系统的性能瓶颈、识别系统的性能极限、验证系统是否能够在预期的负载下正常工作，并评估系统的稳定性和可靠性。\n\n以下是压力测试的一些重要意义：\n\n1.  **发现性能瓶颈：** 通过模拟高负载情况，可以发现系统在哪些方面存在性能瓶颈，例如数据库响应速度、网络带宽、CPU 使用率等。这有助于优化系统的性能，提高系统的吞吐量和响应速度。 \n2.  **验证系统是否满足需求：** 压力测试可以验证系统是否能够在预期的负载下正常工作，并且在高负载情况下仍然保持良好的性能。这有助于确定系统是否满足业务需求，以及确定是否需要进行性能优化或增加资源。 \n3.  **评估系统的稳定性：** 通过模拟高负载情况，可以测试系统在极端条件下的稳定性。如果系统在高负载情况下出现异常或崩溃，这可能表明系统存在潜在的稳定性问题，需要进一步调查和修复。 \n4.  **预测系统的扩展性：** 通过压力测试，可以评估系统在不同负载下的性能表现，并预测系统在未来负载增加时的表现。这有助于规划系统的扩展性，确定何时需要增加更多的资源或进行系统升级。 \n5.  **评估系统的容错性：** 压力测试还可以评估系统在负载增加或出现异常情况下的容错能力。这有助于确定系统在面对异常情况时是否能够保持正常运行，并且能够有效地处理错误和恢复正常状态。 \n\n综上所述，压力测试对于评估系统的性能、稳定性、扩展性和容错性具有重要意义，能够帮助开发团队和运维团队更好地理解系统的性能特征，优化系统的性能，提高系统的可靠性和稳定性。\n\n------\n\n下面是一些其他常用的压力测试指标：\n\n1.  **每秒请求数（Queries Per Second，QPS）：** 指系统在单位时间内处理的查询请求数量，通常以每秒请求数（Queries Per Second，QPS）为单位。QPS 是评估系统性能的重要指标之一，也是吞吐量的一种度量方式。 \n2.  **响应时间分位数（Response Time Percentiles）：** 包括平均响应时间、中位数响应时间（50th percentile）、90th percentile、95th percentile 等，用于描述系统的响应时间分布情况。例如，95th percentile 表示 95% 的请求在该时间内完成。 \n3.  **峰值负载（Peak Load）：** 指系统在压力测试期间达到的最大负载水平，通常用于评估系统在极端条件下的性能表现和稳定性。 \n4.  **持续时间（Duration）：** 指压力测试持续运行的时间长度，通常以分钟或小时为单位。持续时间越长，能够评估系统长期运行时的性能表现和稳定性。 \n5.  **启动时间（Startup Time）：** 指系统从启动到完全响应请求所花费的时间，通常用于评估系统的启动性能和初始化时间。 \n6.  **资源消耗（Resource Consumption）：** 包括 CPU 使用率、内存消耗、网络带宽等系统资源的消耗情况。资源消耗反映了系统在不同负载下的资源利用情况，可以用于优化系统配置和资源调整。 \n7.  **错误类型和频率（Error Types and Frequencies）：** 包括系统返回的错误类型和错误频率。通过分析错误类型和频率，可以识别系统存在的问题并采取相应的措施进行修复。 \n\n综上所述，以上指标是常用于评估系统性能和稳定性的重要指标，可以帮助开发团队和运维团队更好地了解系统的性能特征，优化系统性能，并确保系统能够在不同负载下正常工作。",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 42,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1721896042632441858",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-19T09:19:24.000+00:00",
        "updateTime": "2024-02-26T13:26:47.000+00:00",
        "user": {
          "id": "1721896042632441858",
          "planetCode": "29240",
          "userName": "南侠（准）",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELkfM4IsxxWrB70flGuaDcq55mDxh8r4DuwOJLuluSmRCH9Pk1MFibry5icVgHtfwMmnYGqT49svVKV3X1wMer2OCC3ob5leZX5lF8HMbPo1Qww/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-11-05T14:14:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-11-07T14:23:02.000+00:00",
          "updateTime": "2024-02-02T00:50:41.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "后端",
          "笔记"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": true,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1754073042788556801",
        "title": "RabbitMQ一死信队列介绍和应用",
        "description": "介绍RabbitMQ死信队列的基本概念和其在项目中的应用",
        "content": "## 前言\n最近在做一个BI项目，用到了RabbitMQ异步化生成图表，同时还添加了死信队列处理无法被消费者正常消费的消息。于是便有了这篇文章，下面由我带大家介绍RabbitMQ的死信队列和其在项目中的应用吧。\n\n## 死信和死信队列的概念\n什么是死信？简单来说就是无法被消费和处理的消息。一般生产者将消息投递到broker或者queue，消费者直接从中取出消息进行消费。但有时因为某些原因导致消息不能被消费，导致消息积压在队列中，这样的消息如果没有后续的处理就会变成死信，那么专门存放死信的队列就是死信队列。\n\n## 什么是死信交换机？\n那么什么是死信交换机呢？死信交换机是指专门将死信路由到死信队列的交换机。\n\n## 产生死信的原因\n根据官方文档，我们发现一般有三种场景会产生死信。\n\n![87aceca905ab9eb09b3f08bbfbaf414.png](https://pic.code-nav.cn/post_picture/1608639807578177538/zk6hcBK7-87aceca905ab9eb09b3f08bbfbaf414.png)\n1. 消息超过TTL，即消息过期\n2. 消息被nack或reject，且不予重新入队\n3. 队列达到最大长度\n\n## 死信队列实战和应用\n死信队列的应用并不难，无非就是多定义了一个交换机、routingKey和队列罢了。在声明普通队列时传入Map参数，往Map中put死信队列名称、死信routingKey、消息TTL等参数即可完成死信自动投递到死信队列的流程。通过如下代码即可绑定普通队列和死信交换机了，而且还能设置routingKey和队列长度等参数，无需像传统的那样通过channel绑定。\n\n\n```java\nMap<String, Object> arguments = new HashMap<>(); // 过期时间 arguments.put(\"x-message-ttl\", 10000); // 正常队列设置死信交换机 arguments.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE); // 设置死信routingKey arguments.put(\"x-dead-letter-routing-key\", \"lisi\"); // 设置正常队列的长度限制 arguments.put(\"x-max-length\", 10);\n```\n\n流程图：\n\n![image-20240107185524304.png](https://pic.code-nav.cn/post_picture/1608639807578177538/1axzGMHp-image-20240107185524304.png)\n\n生产者Producer：\n\npublic class Producer {\n    // 普通交换机名称\n    public static final String NORMAL_EXCHANGE = \"normal_exchange\";\n\n    public static void main(String[] args) throws IOException {\n        Channel channel = RabbitMQUtils.getChannel();\n        //死信消息 设置TTL时间\n        AMQP.BasicProperties properties = new AMQP.BasicProperties()\n                .builder().expiration(\"10000\").build();\n\n        // 延迟消息\n        for (int i = 0;i < 10;i++) {\n            String message = i + \"info\";\n            channel.basicPublish(NORMAL_EXCHANGE, \"zhangsan\", properties, message.getBytes());\n        }\n    }\n}\n\n​\n普通队列消费者C1：\n\n```java\npublic class Consumer01 {\n    // 普通交换机名称\n    public static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    // 死信交换机名称\n    public static final String DEAD_EXCHANGE = \"dead_exchange\";\n    // 普通队列名称\n    public static final String NORMAL_QUEUE = \"normal_queue\";\n    // 死信队列名称\n    public static final String DEAD_QUEUE = \"dead_queue\";\n\n    public static void main(String[] args) throws IOException {\n        Channel channel = RabbitMQUtils.getChannel();\n        // 声明死信和普通交换机，类型为direct\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n        // 声明普通队列\n        Map<String, Object> arguments = new HashMap<>();\n        // 过期时间\n        arguments.put(\"x-message-ttl\", 10000);\n        // 正常队列设置死信交换机\n        arguments.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n        // 设置死信routingKey\n        arguments.put(\"x-dead-letter-routing-key\", \"lisi\");\n        // 设置正常队列的长度限制\n        arguments.put(\"x-max-length\", 10);\n\n        // 声明普通队列\n        channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);\n        // 声明死信队列\n        channel.queueDeclare(DEAD_QUEUE, false, false, false, null);\n\n        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, \"zhangsan\");\n        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, \"lisi\");\n        System.out.println(\"consumer01等待接收消息\");\n\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            String msg = new String(message.getBody(), \"UTF-8\");\n            if (msg.equals(\"info5\")) {\n                System.out.println(\"consumer01接收的消息：\" + new String(message.getBody()));\n                System.out.println(msg + \"：此消息是被拒绝的\");\n                channel.basicReject(message.getEnvelope().getDeliveryTag(), false); //拒绝此消息并不放回普通队列\n            } else {\n                System.out.println(\"consumer01接收的消息：\" + new String(message.getBody()));\n                channel.basicAck(message.getEnvelope().getDeliveryTag(), false);\n            }\n        };\n\n        CancelCallback cancelCallback = consumerTag -> {\n            System.out.println(\"C1取消消息\");\n        };\n        channel.basicConsume(NORMAL_QUEUE, false, deliverCallback, cancelCallback);\n    }\n}\n```\n\n死信队列消费者C2\n\n```java\npublic class Consumer02 {\n    // 死信队列名称\n    public static final String DEAD_QUEUE = \"dead_queue\";\n\n    public static void main(String[] args) throws IOException {\n        Channel channel = RabbitMQUtils.getChannel();\n        System.out.println(\"consumer02等待接收消息\");\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            System.out.println(\"consumer02接收的消息：\" + new String(message.getBody()));\n        };\n\n        CancelCallback cancelCallback = consumerTag -> {\n            System.out.println(\"C2取消消息\");\n        };\n        channel.basicConsume(DEAD_QUEUE, true, deliverCallback, cancelCallback);\n    }\n}\n```\n依次启动生产者，和两个消费者，并停掉普通队列的消费者，我们发现生产者发送的消息被死信队列消费者C2给接收了。\n\n![f0921a45fdc93175d4b914af3302340.jpg](https://pic.code-nav.cn/post_picture/1608639807578177538/m8risyQD-f0921a45fdc93175d4b914af3302340.jpg)\n\n> 在上面的代码中，我在普通队列中设置了消息的TTL为5s，但是我又在生产者设置发送的消息TTL为10s，那么RabbitMQ会以哪个为准呢？其实RabbitMQ会以较短的TTL为准\n\n\n## BI项目添加死信队列\n### 声明交换机、队列和routingKey的配置类\n\n```java\n@Configuration\npublic class TtlQueueConfig {\n    private final String COMMON_EXCHANGE = \"bi_common_exchange\"; // 普通交换机名称\n    private final String COMMON_QUEUE = \"bi_common_queue\"; // 普通队列名称\n    private final String DEAD_LETTER_EXCHANGE = \"bi_dead_letter_exchange\"; // 死信交换机名称\n    private final String DEAD_LETTER_QUEUE = \"bi_dead_letter_queue\"; // 死信队列名称\n    private final String COMMON_ROUTINGKEY = \"bi_common_routingKey\"; // 普通routingKey\n    private final String DEAD_LETTER_ROUTINGKEY = \"bi_dead_letter_routingKey\"; // 死信routingKey\n\n    // 普通交换机\n    @Bean(\"commonExchange\")\n    public DirectExchange commonExchange() {\n        return new DirectExchange(COMMON_EXCHANGE);\n    }\n\n    // 死信交换机\n    @Bean(\"deadLetterExchange\")\n    public DirectExchange deadLetterExchange() {\n        return new DirectExchange(DEAD_LETTER_EXCHANGE);\n    }\n\n    // 普通队列\n    @Bean(\"commonQueue\")\n    public Queue commonQueue() {\n        Map<String, Object> map = new HashMap<>(3);\n        map.put(\"x-message-ttl\", 20000);\n        map.put(\"x-dead-letter-exchange\", DEAD_LETTER_EXCHANGE);\n        map.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTINGKEY);\n        return QueueBuilder.durable(COMMON_QUEUE).withArguments(map).build();\n    }\n\n    // 死信队列\n    @Bean(\"deadLetterQueue\")\n    public Queue deadLetterQueue() {\n        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();\n    }\n\n    @Bean\n    public Binding commonQueueBindingCommonExchange(@Qualifier(\"commonQueue\") Queue commonQueue,\n                                                    @Qualifier(\"commonExchange\") DirectExchange commonExchange) {\n        return BindingBuilder.bind(commonQueue).to(commonExchange).with(COMMON_ROUTINGKEY);\n    }\n\n    @Bean\n    public Binding deadQueueBindingDeadExchange(@Qualifier(\"deadLetterQueue\") Queue deadLetterQueue,\n                                                @Qualifier(\"deadLetterExchange\") DirectExchange deadLetterExchange){\n        return BindingBuilder.bind(deadLetterQueue).to(deadLetterExchange).with(DEAD_LETTER_ROUTINGKEY);\n    }\n}\n```\n\n### 普通消费者（负责异步生成图表信息）\n\n```java\n@Configuration\npublic class TtlQueueConfig {\n    private final String COMMON_EXCHANGE = \"bi_common_exchange\"; // 普通交换机名称\n    private final String COMMON_QUEUE = \"bi_common_queue\"; // 普通队列名称\n    private final String DEAD_LETTER_EXCHANGE = \"bi_dead_letter_exchange\"; // 死信交换机名称\n    private final String DEAD_LETTER_QUEUE = \"bi_dead_letter_queue\"; // 死信队列名称\n    private final String COMMON_ROUTINGKEY = \"bi_common_routingKey\"; // 普通routingKey\n    private final String DEAD_LETTER_ROUTINGKEY = \"bi_dead_letter_routingKey\"; // 死信routingKey\n\n    // 普通交换机\n    @Bean(\"commonExchange\")\n    public DirectExchange commonExchange() {\n        return new DirectExchange(COMMON_EXCHANGE);\n    }\n\n    // 死信交换机\n    @Bean(\"deadLetterExchange\")\n    public DirectExchange deadLetterExchange() {\n        return new DirectExchange(DEAD_LETTER_EXCHANGE);\n    }\n\n    // 普通队列\n    @Bean(\"commonQueue\")\n    public Queue commonQueue() {\n        Map<String, Object> map = new HashMap<>(3);\n        map.put(\"x-message-ttl\", 20000);\n        map.put(\"x-dead-letter-exchange\", DEAD_LETTER_EXCHANGE);\n        map.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTINGKEY);\n        return QueueBuilder.durable(COMMON_QUEUE).withArguments(map).build();\n    }\n\n    // 死信队列\n    @Bean(\"deadLetterQueue\")\n    public Queue deadLetterQueue() {\n        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();\n    }\n\n    @Bean\n    public Binding commonQueueBindingCommonExchange(@Qualifier(\"commonQueue\") Queue commonQueue,\n                                                    @Qualifier(\"commonExchange\") DirectExchange commonExchange) {\n        return BindingBuilder.bind(commonQueue).to(commonExchange).with(COMMON_ROUTINGKEY);\n    }\n\n    @Bean\n    public Binding deadQueueBindingDeadExchange(@Qualifier(\"deadLetterQueue\") Queue deadLetterQueue,\n                                                @Qualifier(\"deadLetterExchange\") DirectExchange deadLetterExchange){\n        return BindingBuilder.bind(deadLetterQueue).to(deadLetterExchange).with(DEAD_LETTER_ROUTINGKEY);\n    }\n}\n\n普通消费者（负责异步生成图表）\n\n@Component\n@Slf4j\npublic class BIMessageConsumer {\n    @Resource\n    private ChartService chartService;\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Resource\n    private AIManager aiManager;\n\n    @Resource\n    RedisTemplate<String, Object> redisTemplate;\n\n    // 制定消费者监听哪个队列和消息确认机制\n    @SneakyThrows\n    @RabbitListener(queues = {\"bi_common_queue\"}, ackMode = \"MANUAL\")\n    public void receiveMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) {\n        log.info(\"receiveMessage is {}\", message);\n        if(StringUtils.isBlank(message)) {\n            // 如果失败，消息拒绝\n            channel.basicNack(deliveryTag, false, false);\n            log.info(\"消息为空拒绝接收\");\n            log.info(\"此消息正在被转发到死信队列中\");\n        }\n\n        long chartId = Long.parseLong(message);\n        Chart chart = chartService.getById(chartId);\n        if (chart == null) {\n            channel.basicNack(deliveryTag, false, false);\n            log.info(\"图标为空拒绝接收\");\n            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR, \"图表为空\");\n        }\n\n        // 先修改图表任务状态为“执行中”。等执行成功后，修改为“已完成”、保存执行结果；执行失败后，状态修改为“失败”，记录任务失败信息。\n        Chart updateChart = new Chart();\n        updateChart.setId(chart.getId());\n        updateChart.setStatus(\"running\");\n        boolean b = chartService.updateById(updateChart);\n        if (!b) {\n            channel.basicNack(deliveryTag, false, false);\n            handlerChartUpdateError(chart.getId(), \"更新图表执行状态失败\");\n            return;\n        }\n        // 调用AI\n        String result = aiManager.doChat(CommonConstant.BI_MODEL_ID, buildUserInput(chart));\n        String[] splits = result.split(\"【【【【【\");\n        if (splits.length < 3) {\n            channel.basicNack(deliveryTag, false, false);\n            handlerChartUpdateError(chart.getId(), \"AI生成错误\");\n            return;\n        }\n        String genChart = splits[1].trim();\n        String genResult = splits[2].trim();\n        Chart updateChartResult = new Chart();\n        updateChartResult.setId(chart.getId());\n        updateChartResult.setGenChart(genChart);\n        updateChartResult.setGenResult(genResult);\n        updateChartResult.setStatus(\"succeed\");\n        boolean updateResult = chartService.updateById(updateChartResult);\n        if (!updateResult) {\n            channel.basicNack(deliveryTag, false, false);\n            handlerChartUpdateError(chart.getId(), \"更新图表成功状态失败\");\n        }\n        Long userId = chartService.queryUserIdByChartId(chartId);\n        String myChartId = String.format(\"lingxibi:chart:list:%s\", userId);\n        redisTemplate.delete(myChartId);\n\n        // 如果任务执行成功，手动执行ack\n        channel.basicAck(deliveryTag, false);\n    }\n\n\n    private void handlerChartUpdateError(long chartId, String execMessage) {\n        Chart updateChartResult = new Chart();\n        updateChartResult.setId(chartId);\n        updateChartResult.setStatus(\"failed\");\n        updateChartResult.setExecMessage(execMessage);\n        boolean updateResult = chartService.updateById(updateChartResult);\n        if (!updateResult) {\n            log.error(\"更新图表失败状态失败\" + chartId + \",\" + execMessage);\n        }\n    }\n\n    /**\n     * 构建用户输入\n     * @param chart\n     * @return\n     */\n    private String buildUserInput(Chart chart) {\n        String goal = chart.getGoal();\n        String chartType = chart.getChartType();\n        String csvData = chart.getChartData();\n\n        // 构造用户输入\n        StringBuilder userInput = new StringBuilder();\n        userInput.append(\"分析需求：\").append(\"\\n\");\n        // 拼接分析目标\n        String userGoal = goal;\n        if (StringUtils.isNotBlank(chartType)) {\n            userGoal += \",请使用\" + chartType;\n        }\n        userInput.append(userGoal).append(\"\\n\");\n        userInput.append(\"原始数据：\").append(\"\\n\");\n        // 压缩后的数据\n\n        userInput.append(csvData).append(\"\\n\");\n        return userInput.toString();\n    }\n}\n```\n### 死信队列消费者（负责处理死信）\n收到死信后我是直接确认了，这种方式可能不好，你也可以换成其他方式比如重新入队，或者写入数据库并打上日志等等。\n\n```java\n@Component\n@Slf4j\npublic class TtlQueueConsumer {\n    @Resource\n    BIMessageProducer biMessageProducer;\n\n    @SneakyThrows\n    @RabbitListener(queues = \"bi_dead_letter_queue\", ackMode = \"MANUAL\")\n    public void doTTLMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) {\n        log.info(\"已经接受到死信消息：{}\", message);\n        biMessageProducer.sendMessage(message);\n        channel.basicAck(deliveryTag, false);\n    }\n}\n```\n如果我的文章对你有帮助的话，不妨给我点个赞呗，我会持续带来不一样的内容。如果对Java相关知识感兴趣的话，可以关注我，带你走进Java的世界。\n\n​",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1608639807578177538/Gz1wdtU7-OIP (1).jpg",
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 93,
        "thumbNum": 6,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608639807578177538",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-04T09:22:57.000+00:00",
        "updateTime": "2024-02-26T11:19:26.000+00:00",
        "user": {
          "id": "1608639807578177538",
          "planetCode": "24506",
          "userName": "吃遍全国汉堡\uD83C\uDF54",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/hib5bbuJu0U3DnxEuGVHEiaGEQr55285A2zaluuxopzXxX5xXFwwfbia7uZcbzpQ5HUDIBeZsIq7VMtfdo1icbL86w/132",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [
            "Java"
          ],
          "place": "江苏淮安",
          "birthday": "2003-10-15",
          "school": "",
          "major": "计算机科学与技术",
          "education": "本科",
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": null,
          "blog": "https://blog.csdn.net/xyendjsj?spm=1000.2115.3001.5343",
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-07-04T00:04:09.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-30T01:43:11.000+00:00",
          "updateTime": "2024-02-08T04:37:32.000+00:00"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "7266",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "727"
  },
  "message": "ok"
}